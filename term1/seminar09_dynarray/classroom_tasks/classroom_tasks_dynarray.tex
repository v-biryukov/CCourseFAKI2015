\documentclass{article}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{amsmath} 
\usepackage{amsfonts}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{upgreek}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{geometry}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{ccaption}
\usepackage{multicol}

\hypersetup{
   colorlinks=true,
   citecolor=blue,
   linkcolor=black,
   urlcolor=blue
}

\usepackage{listings}
%\setlength{\columnsep}{1.5cm}
%\setlength{\columnseprule}{0.2pt}

\usepackage[absolute]{textpos}

\usepackage{colortbl,graphicx,tikz}
\definecolor{X}{rgb}{.5,.5,.5}


\begin{document}
\pagenumbering{gobble}
\lstset{
  language=C,                % choose the language of the code
  basicstyle=\linespread{1.1}\ttfamily,
  columns=fixed,
  fontadjust=true,
  basewidth=0.5em,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray},
  stringstyle=\ttfamily\color{orange!50!black},
  showstringspaces=false,
  numbersep=5pt,
  numberstyle=\tiny\color{black},
  numberfirstline=true,
  stepnumber=1,                   % the step between two line-numbers.        
  numbersep=10pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
  showstringspaces=false,         % underline spaces within strings
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=true,         % sets if automatic breaks should only happen at whitespace
  xleftmargin=.2in,
  extendedchars=\true,
  keepspaces = true,
}
\lstset{literate=%
   *{0}{{{\color{red!20!violet}0}}}1
    {1}{{{\color{red!20!violet}1}}}1
    {2}{{{\color{red!20!violet}2}}}1
    {3}{{{\color{red!20!violet}3}}}1
    {4}{{{\color{red!20!violet}4}}}1
    {5}{{{\color{red!20!violet}5}}}1
    {6}{{{\color{red!20!violet}6}}}1
    {7}{{{\color{red!20!violet}7}}}1
    {8}{{{\color{red!20!violet}8}}}1
    {9}{{{\color{red!20!violet}9}}}1
}
\newpage

\title{Семинар \#9: Сегменты памяти. Динамический массив. Классные задания.\vspace{-5ex}}\date{}\maketitle
\section*{Часть 1: Сегменты памяти}
\begin{multicols}{2}
\begin{center}
\includegraphics[scale=1.1]{../images/memory_layout.png}
\end{center}
\columnbreak
\begin{enumerate}
\item \textbf{Сегмент памяти Стек (Stack)} \\
\begin{itemize}
\item При обычном объявлении переменных и массивов все они создаются в стеке: 
\begin{lstlisting}
int a; 
int array[10];
\end{lstlisting}


\item Память на локальные переменные функции выделяется при вызове этой функции и освобождается при завершении функции.
\item Маленький размер (несколько мегабайт, зависит от настроек операционной системы).
\item Выделение памяти происходит быстрее чем в куче
\end{itemize}
\item \textbf{Сегмент памяти Куча (Heap)} \\
\begin{itemize}
\item Выделеть память в куче можно с помощью стандартной функции \texttt{malloc}. \\
\begin{lstlisting}
int* p = malloc(10 * sizeof(int));
\end{lstlisting}
\item Освободить память в куче можно с помощью стандартной функции \texttt{free}
\begin{lstlisting}
free(p);
\end{lstlisting}
\item Память можно выделяется/освобождать в любом месте.
\item Размер ограничен свободной оперативной памятью.
\item Выделение памяти происходит медленней чем в стеке
\end{itemize}
\end{enumerate}
\end{multicols}

\begin{enumerate}
\setcounter{enumi}{2}

\item \textbf{Сегмент памяти Data}
\begin{itemize}
\item В этом сегменте хранятся инициализированные глобальные и статические переменные а также строковые литералы
\end{itemize}

\item \textbf{Сегмент памяти BSS}
\begin{itemize}
\item В этом сегменте хранятся неинициализированные глобальные и статические переменные
\item В большинстве систем все эти данные автоматически инициализируются нулями
\end{itemize}

\item \textbf{Сегмент памяти Text}
\begin{itemize}
\item В этом сегменте хранится машинный код программы (Код на языке C, сначала, переводится в код на языке Ассемблера, а потом в машинный код. Как это происходит смотрите ниже.).
\item Адрес функции - адрес первого байта инструкций в этом сегменте.
\end{itemize}
\end{enumerate}


\subsection*{Создание массива в разных сегментах памяти}
Ниже представлен пример программы в которой создаюся 4 массива в разных сегментах памяти.
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

int array_data[5] = {1, 2, 3, 4, 5};
int array_bss[5];

int main() {
    int array_stack[5];
    int* array_heap = (int*)malloc(5 * sizeof(int));
}
\end{lstlisting}
\begin{itemize}
\item Напечатайте адрес начала каждого из массивов. Помните, что для печати адресов используется спецификатор \texttt{\%p}.
\end{itemize}



\subsection*{Переполнение стека -- Stackoverflow}
\begin{itemize}
\item Определите размер стека на вашей системе экспериментальным путём. Создайте массив такого большого размера на стеке, чтобы перестала работать. Минимальный размер массива, при котором падает программа будет примерно равен размеру стека.
\item При каждом вызове функции в стеке хранятся локальные переменные функции, аргументы функции а также адрес возврата функции. Даже функция без локальных переменных и аргументов будет хранить на стеке как минимум адрес возврата (8 байт). Определите размер стека на вашей системе экспериментальным путём с помощью рекурсии.
\end{itemize}

\subsection*{Статические переменные}
Помимо глобальных переменных, в сегменте Data хранятся статические переменные. Такие переменные объявляются внутри функций, но создаются в сегменте Data и не удаляются при завершении функции. Вот пример функции со статической переменной.
\begin{lstlisting}
#include <stdio.h>
void counter() {
    static int n = 0;
    n++;
    printf("%i\n", n);
}

int main() {
    counter();
    counter();
    counter();
}
\end{lstlisting}
Обратите внмание, что в этой функции строка \texttt{static int n = 0;} не исполняется при заходе в функцию. Эта строка просто объявляет инициализирует статическую переменную, причём инициализация происходит в самом начале исполнения программы (даже до функции \texttt{main}). 

\begin{itemize}
\item Создайте функцию \texttt{adder}, которая будет принимать на вход число и возвращать сумму всех чисел, которые приходили на вход этой функции за время выполнения программы.
\begin{lstlisting}
printf("%i\n", adder(10));  // Напечатает 10
printf("%i\n", adder(15));  // Напечатает 25
printf("%i\n", adder(70));  // Напечатает 95
\end{lstlisting}
\end{itemize}

\newpage
\section*{Часть 2: Статический массив внутри структуры}
В файле \texttt{0array\_in\_struct.c} содержится минимальный пример массива, который хранится внутри структуры. Максимальная вместимость массива равна \texttt{100}. А размер хранится внутри структуры и может принимать значения от 0 до 100. Функция \texttt{push\_back} принимает на вход адрес на такую структуру и число \texttt{value}, а затем добавляет это число в конец массива.\\

Зачем хранить массив внутри структуры, если можно было бы просто создать его без струтуры? На самом деле у такого подхода много преимуществ:
\begin{enumerate}
\item Он позволяет нам самим описать поведение массива при добавлении и удалении элементов.
\item Мы можем передавать такой массив внутри функций также как и обычные переменные.
\item Такой подход распространяется на более сложные структуры данных
\end{enumerate}

Напишите следующие функции для работы с этим массивом:
\begin{itemize}
\item \texttt{array\_print} -- эта функция должна принимать на вход адрес структуры \texttt{Array} и печатать массив на экран.
\item \texttt{array\_is\_empty} -- эта функция должна принимать на вход адрес структуры \texttt{Array} и возвращать \texttt{1}, если массив пуст и \texttt{0} иначе.
\item \texttt{int array\_get(const Array* a, int index)} эта функция должна возвращать число, которое лежит по индексу \texttt{index} в массиве.
\item \texttt{void array\_set(const Array* a, int index, int value)} эта функция должна устанавливать элемент массива, лежащий по индексу \texttt{index} значением \texttt{value}.
\item Добавьте в функцию
\end{itemize}

\newpage
\section*{Часть 3: Динамический массив}
\begin{lstlisting}
#include <stdio.h>
struct dynarray {
    int size;
    int capacity;
    int* values;
};
typedef struct dynarray Dynarray;
\end{lstlisting}

В файле \texttt{2dynarray.c} содержится код описывающий динамический массив. Измените код так, чтобы происходило перевыделение памяти тогда, когда размер массива начинает превышать вместимость.




\newpage
\section*{Часть 5: Абстрактные типы данных: Стек и Очередь, Дек и Очередь с приоритетом}
\textbf{Абстракстный тип данных (АТД)} - это математическая модель для типов данных, которая задаёт поведение этих типов, но не их внутреннею реализацию.\\

\textbf{Стек (Stack)} - это АТД, который представляет собой коллекцию элементов, менять которые можно только с помощью двух операций:
\begin{itemize}
\item \texttt{push} - добавить элемент в стек.
\item \texttt{pop} - извлечь из стека последний добавленный элемент.
\end{itemize}
Таким образом, поведение стека задаётся этими двумя операциями. Так как стек - это абстрактный тип данных, то его внутренняя реализация на языке программирования может быть самой разной. Стек можно сделать на основе статического массива, на основе динамического массива(\texttt{malloc}/\texttt{free}) или на основе связного списка. Внутренняя реализация не важна, важно только наличие операций \texttt{push} и \texttt{pop}. \\
Не нужно путать абстракстный тип данных стек с сегментом памяти стек.\\

\textbf{Очередь (Queue)} - это АТД, который представляет собой коллекцию элементов, менять которые можно только с помощью двух операций:
\begin{itemize}
\item \texttt{enqueue} - добавить элемент в очередь.
\item \texttt{dequeue} - извлечь из очереди первый добавленный элемент из оставшихся.
\end{itemize}

\begin{center}
\includegraphics[scale=0.31]{../images/stack_queue.png}
\end{center}

\textbf{Дек (Deque = Double-ended queue)} - это АТД, который представляет собой коллекцию элементов, менять которые можно только с помощью четырёх операций:
\begin{itemize}
\item \texttt{push\_back} - добавить элемент в конец.
\item \texttt{push\_front} - добавить элемент в начало.
\item \texttt{pop\_back} - извлечь элемент с конца.
\item \texttt{pop\_front} - извлечь элемент с начала.\\
\end{itemize}

\textbf{Очередь с приоритетом (Priority Queue)} - это АТД, который представляет собой коллекцию элементов, менять которые можно только с помощью двух операций:
\begin{itemize}
\item \texttt{insert} - добавить элемент.
\item \texttt{extract\_best} - извлечь из очереди элемент с наибольшим приоритетом. 
\end{itemize}
То, что будет являться приоритетом может различаться. Это может быть как сам элемент, часть элемента (например, одно из полей структуры) или другие данные, подаваемые на вход операции \texttt{insert} вместе с элементом. В простейшем случае, приоритетом является сам элемент (тогда очередь с приоритетом просто возвращает максимальный элемент) или сам элемент со знаком минус (тогда очередь с приоритетом возвращает минимальный элемент).


\newpage
\section*{Часть 6: Реализация стека на основе статического массива}
\begin{multicols}{2}
\begin{lstlisting}
#include <stdio.h>
struct stack {
    int size;
    int values[100];
};
typedef struct stack Stack;

void stack_push(Stack* s, int x)
{
    s->values[s->size] = x;
    s->n += 1;
}
\end{lstlisting}

\begin{center}
\includegraphics[width=0.95\linewidth]{../images/stack.png}
\end{center}
\end{multicols}

\subsubsection*{Задачи:}
\begin{enumerate}
\item Написать функцию \texttt{int stack\_pop(Stack* s, int x)}. Протестируёте стек: проверьте, что выведет программа, написанная выше.
\item Написать функцию \texttt{int stack\_is\_empty(const Stack* s)}, которая возвращает 1 если стек пуст и 0 иначе.
\item Написать функцию \texttt{int stack\_get(const Stack* s)}, которая возвращает элемент, находящийся в вершине стека, но не изменяет стек.
\item Написать функцию \texttt{void stack\_print(const Stack* s)}, которая распечатывает все элементы стека.
\item Одна из проблем текущей реализации: размер массива 100 задан прямо в определении структуры. Если мы решим изменить максимальный размер стека, то придётся изменять это число по всему коду программы.  Чтобы решить эту проблему введите \texttt{\#define}-константу \texttt{CAPACITY}:
\begin{lstlisting}
#define CAPACITY 100
\end{lstlisting}
\item Что произойдёт, если вызвать \texttt{stack\_push()} при полном стеке? Обработайте эту ситуацию. Программа должна печатать сообщение об ошибке и завершаться с аварийным кодом завершения. Чтобы завершить программу таким образом можно использовать функцию \texttt{exit()} из библиотеки \texttt{stdlib.h}. Пример вызова: \texttt{exit(1)};
\item Аналогично при вызове \texttt{stack\_pop()} и \texttt{stack\_get()} при пустом стеке.
\item Введите функцию \texttt{stack\_init()}, которая будет ответственна за настройку стека сразу после его создания. В данном случае, единственное, что нужно сделать после создания стека это занулить n.
\item Предположим, что вы однажды захотите использовать стек не для целочисленных чисел типа \texttt{int}, а для какого-нибудь другого типа (например \texttt{char}). Введите синоним для типа элементов стека:
\begin{verbatim}
typedef int Data;
\end{verbatim}
Измените тип элемента стека во всех функциях с \texttt{int} на \texttt{Data} (тип поля \texttt{n} менять не нужно). Теперь вы в любой момент сможете изменить тип элементов стека, изменив лишь одну строчку.
\item Сложные скобки. Решить задачу определения правильной скобочной последовательности, используя стек символов. Виды скобок: () \{\} [] <>. Пример неправильной последовательности: (\{<\}>)
\end{enumerate}

\newpage
\section*{Часть 7: Реализация стека на основе динамического массива}
Описание такого стека выглядит следующим образом:
\begin{lstlisting}
struct stack {
    int capacity;
    int size;
    Data* values;
};
typedef struct stack Stack;
\end{lstlisting}
Введено новое поле \texttt{capacity}. В нём будет хранится количество элементов стека, под которые уже выделена память. В отличии от предыдущего варианта стека, это значение будет меняться. \\
values теперь не статический массив, а указатель. Вы должны выделить необходимое место для стека в функции \texttt{stack\_init()}. Начальное значение capacity можно выбрать самостоятельно либо передавать на вход функции \texttt{stack\_init()}. При заполнении стека должно происходить перевыделение памяти с помощью функции \texttt{realloc}.
\end{document}