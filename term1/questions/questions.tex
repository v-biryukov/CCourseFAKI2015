\documentclass{article}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{amsmath} 
\usepackage{amsfonts}
\usepackage{upgreek}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{geometry}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{ccaption}
\usepackage{mathrsfs}
\usepackage[shortlabels]{enumitem}


\begin{document}
\pagenumbering{gobble}

\section*{Теория:}

\section*{Модуль 1}
\begin{enumerate}
\item \textbf{Основы}\\

\begin{enumerate}[a.]
\item \textbf{Основные команды командной строки}\\
\texttt{cd}, \texttt{ls} (опции \texttt{-l} и \texttt{-a}), \texttt{pwd}, \texttt{cp}, \texttt{mv}, \texttt{rm} (опция \texttt{-r}), \texttt{mkdir}, \texttt{find}(опция \texttt{-name}), программа \texttt{top}, компилятор \texttt{gcc} (опции \texttt{-o}, \texttt{-std=c99}, \texttt{-lm} и \texttt{-S}). Перенаправление вывода \texttt{>}. Возвращаемое значение функции \texttt{main}. Функция \texttt{exit} из библиотеки \texttt{stdlib.h}.

\item \textbf{Стандартный ввод/вывод}\\
Ввод и вывод в языке C. Функции \texttt{printf} и \texttt{scanf} из библиотеки \texttt{stdio.h}.


\item \textbf{Ветвление и циклы}\\
Оператор ветвления \texttt{if-else}. Использования логических операторов в условии оператора ветвления.  Цикл \texttt{while}. Цикл \texttt{for}. Цикл \texttt{do while}. Операторы \texttt{break} и \texttt{continue}. Тернарный оператор. Чем отличается тернарный оператор от \texttt{if-else}?


\item \textbf{Операторы}\\
Арифметические операторы(\texttt{+ - * / \%}). Что делает оператор деления, если аргументы целочисленные и если аргументы -- числа с плавающей точкой? Оператор присваивания (\texttt{=}). Оператор присваивания сложения и подобные ему (\texttt{+= -= *= /= \%=}). Операторы инкремента и декремента (\texttt{++  $--$}). Префиксный  и постфиксный инкремент/декремент, чем они отличаются. Операторы сравнения (\texttt{== != > < >= <=}). Что возвращают операторы сравнения? Логические операторы (\texttt{!  ||  \&\&}). Побитовые операторы (\texttt{$\sim$  \&  |  \textasciicircum \quad <{}<  >{}>}). Тернарный оператор (\texttt{? :}). Оператор нахождения адреса (\texttt{\&}). Оператор нахождения размера переменной (\texttt{sizeof}). Оператор разыменования (\texttt{*}). Оператор обращения к элементу массива (\texttt{[]}) и его связь с оператором разыменования. Оператор доступа к полю структуры (\texttt{.}). Оператор доступа к полю структуры через указатель на структуру (\texttt{->}). Приоритет операторов. 
\end{enumerate}




\item \textbf{Массивы}\\


\begin{enumerate}[a.]
\item \textbf{Создание и инициализация массивов}\\
Массивы. Элемент массива и индекс массива. Как хранятся массивы в памяти? Объявление и определение массивов. Инициализация массивов. Можно ли присваивать массив другому массиву с помощью оператора присваивания? Как распечатать массив? Размер массивов. Как узнать размер массива?

\item \textbf{Передача массивов в функции}\\
Как передаются массивы в функции? Array to pointer decay. Как вернуть массив из функции?

\item \textbf{Двумерные массивы}\\
Объявление, определение и инициализация двумерного массива. Как двумерный массив хранится в памяти? Как двумерный массив передаётся внутрь функции?

\item \textbf{Простейшие алгоритмы}\\
Один простой алгоритм сортировки (выбором или пузырьком). Алгоритм перемножения матриц. 
\end{enumerate}


\item \textbf{Функции}\\

\begin{enumerate}[a.]
\item \textbf{Основы работы с функциями}\\
Параметры и аргументы функции. Возвращаемое значение функции. Объявления функции. Прототип функции. Определение функции.
Возврат из функции. Ключевое слово \texttt{return}. Ключевое слово \texttt{void}.

\item \textbf{Передача в функцию}\\
Как переменные базовых типов и структуры передаются в функции? Как массивы передаюся в функции? Три типа передачи аргументов в функцию (по значению, через указатель, через константный указатель). Передача одномерных и многомерных массивов в функции.

\item \textbf{Рекурсия}\\
Рекурсия. Алгоритмы вычисления факториала, чисел Фибоначчи и бинарного возведения в степень с помощью рекурсии.
Переполнение стека при рекурсии.
\end{enumerate}

   
\item \textbf{Типы данных}\\   


\begin{enumerate}[a.]
\item \textbf{Создание переменных}\\
Переменные. Понятия объявления, определения, в чём различие между ними. Инициализация и присваивание, в чём различие между ними.

\item \textbf{Целочисленные типы данных}\\
Типы целочисленных переменных: \texttt{char}, \texttt{short}, \texttt{int}, \texttt{long}, \texttt{long long} и их \texttt{unsigned}-аналоги. Типичные размеры этих типов на современных системах и диапазоны значений, которые могут принимать данные типы. Создание новых названий для типов с помощью ключевого слова \texttt{typedef}. Что такое тип \texttt{size\_t}. Когда он используется? Типы фиксированной ширины: \texttt{int8\_t}, \texttt{uint8\_t}, \texttt{int16\_t} и другие.

\item \textbf{Представление целочисленных переменных в памяти}\\
Как хранятся в памяти отрицательные числа? Дополнительный код.  Целочисленное переполнение. Неопределённое поведение при целочисленном переполнении.

\item \textbf{Константы}\\
Квалификатор типа \texttt{const}. Разница между определение константы с помощью директивы \texttt{\#define} и квалификатора \texttt{const}.

\item \textbf{Типы чисел с плавающей точкой}\\
Типы чисел с плавающей точкой: \texttt{float}, \texttt{double} и \texttt{long double}. Типичные размеры этих типов на современных системах и диапазоны значений, которые могут принимать данные типы. (*)Представление чисел с плавающей точкой в памяти. (*)Стандарт IEEE 754.

\item \textbf{Приведение типов.}\\
Неявное приведение типов. Когда оно происходит? Явное приведение типов, как привести один тип в другой.

\item \textbf{Математическая библиотека \texttt{math.h}}\\
Функции \texttt{sqrt}, \texttt{exp}, \texttt{sin}, \texttt{cos}, \texttt{tan}, \texttt{asin}, \texttt{acos}, \texttt{atan}, \texttt{atan2}, \texttt{fabs}, \texttt{floor}, \texttt{log}, \texttt{pow}. Сравнение двух чисел с плавающей точкой с помощью функции \texttt{fabs}.
\end{enumerate}



\item \textbf{Строки}\\

\begin{enumerate}[a.]
\item \textbf{Символы}\\
Кодировка ASCII. Использование целочисленного типа \texttt{char} для хранения кодов символов. Чтение и запись символов (спецификатор \texttt{\%с}).

\item \textbf{Строки в языке C}\\
Что такое строка в языке C? Как строки хранятся в языке C. Символ завершения строки. Чтение и запись строк (спецификатор \texttt{\%s}).

\item \textbf{Библиотека \texttt{string.h}}\\
Функции \texttt{strlen}, \texttt{strcpy}, \texttt{strcmp}. Функции \texttt{sprintf} и \texttt{sscanf}, использование этих функций для конвертации числа в строку и наоборот.

\item \textbf{Аргументы командной строки}\\
Аргументы функции \texttt{main}: \texttt{argc} и \texttt{argv}. Что они означают и как их использовать.
\end{enumerate}





\item \textbf{Указатели и структуры}\\

\begin{enumerate}[a.]
\item \textbf{Указатели}\\
Объявление указателя. Инициализация указателя. Размер указателя на 32-х и 64-х битных системах.

\item \textbf{Арифметика указателей}\\
Операторы, применимые к указателям и что они делают: \texttt{++}, \texttt{--}, прибавление целого числа, вычитание двух указателей, разыменование и оператор взятие индекса (\texttt{[]}). Операции нахождения адреса (\texttt{\&}) переменной и операция разыменования \texttt{*} указателя.

\item \textbf{Указатели разных типов.}\\
Чем различаются указатели разных типов. Указатель \texttt{void*}. Константный указатель (\texttt{const int* p}) и постоянный указатель (\texttt{int* const p}). Передача в функцию переменных по указателю. Передача массивов в функции.

\item \textbf{Структуры}\\
Объявление структуры. Определение структуры. Инициализация структуры. Поля структуры. Доступ к полю структуры.

\item \textbf{Указатели на структуры}\\
Доступ к полю по указателю на структуру. Оператор \texttt{->}. Передача структур в функции и возврат их из функций.

\item \textbf{Выравнивание}\\
Размер структуры. Выравнивание полей структуры.
\end{enumerate}



\item \textbf{Сегменты}\\

\begin{enumerate}[a.]
\item \textbf{Сегменты памяти}\\
Что такое сегменты памяти? Ошибка Segmentation Fault.

\item \textbf{Сегмент памяти стек}\\
Сегмент памяти стек(не путать с абстрактным типом данных -- стек). Выделение и освобождение памяти в стеке. Размер стека. Реализация вызова функций с помощью сегмента памяти стек. Стековый кадр, что в нём хранится. Адрес возрата.  Как можно переполнить стек? 

\item \textbf{Сегмент памяти куча}\\
Динамическое выделение и освобождение памяти в куче: \texttt{malloc}, \texttt{calloc}, \texttt{realloc} и \texttt{free}. Преимущества и недостатки кучи перед стеком. Динамический массив, его создании с помощью функции \texttt{malloc}.

\item \textbf{Двумерный динамический массив}\\
Динамический двумерный массив, его создании с помощью функции \texttt{malloc}. Хранение двумерного массива в виде одномерного массива.

\item \textbf{Утечки}\\
Утечки памяти. Основы работы с valgrind.

\item \textbf{Сегмент памяти Данные}\\
Сегменты памяти data и rodata. Чем они различаются? Что такое глобальные переменные. Что такое статические переменные. Где хранятся глобальные и статические переменные? Когда и как инициализируются глобальные и статические переменные? Строковые литералы. Где хранятся строковые литералы?

\item \textbf{Сегмент памяти Текст}\\
Сегмент памяти text. Преобразование кода программы в код на языке ассемблера и в двоичный код. Указатели на функции. Объявление указателей на функции. Передача указателей на функции в другие функции. Стандартная функция \texttt{qsort} и передача в ней компаратора.
\end{enumerate}



\item \textbf{Файлы}\\

\begin{enumerate}[a.]
\item \textbf{Шестнадцатеричная система счисления}\\
Шестнадцатеричная система счисления. Печать и считывания целочисленных переменных в шестнадцатеричной системе с помощью спецификатора \texttt{\%x}.

\item \textbf{Память}\\
Порядок байт. Little endian и big endian. Просмотр байт объекта с помощью указателя типа \texttt{unsigned char*}. Функции \texttt{memset}, \texttt{memcpy}, \texttt{memmove} из стандартной библиотеки.

\item \textbf{Алиасинг}\\
Что такое алиасинг? Strict Aliasing Rule. Неопределённое поведение при алиасинге. 


\item \textbf{Текстовые файлы}\\
Открытие и закрытие файла, функции \texttt{fopen} и \texttt{fclose}. Режимы открытия файла \texttt{"w"} и \texttt{"r"}.
Запись/чтение с помощью функций \texttt{fprintf} и \texttt{fscanf}. Запись/чтение по одному байту с помощью функций \texttt{fputc} и \texttt{fgetc}. Что возвращает функция \texttt{fgetc}? 


\item \textbf{Бинарные файлы}\\
Бинарный и текстовый режимы открытия файла, в чём их отличие. Как хранится перенос строки на операционных системах Linux и Windows. Запись из памяти в файл и чтение из файла в память с помощью функций \texttt{fwrite} и \texttt{fread}. Функции \texttt{fseek} и \texttt{ftell}.
\end{enumerate}






\item \textbf{Динамический массив}\\

\begin{enumerate}[a.]
\item \textbf{Виды массивов в языке C}\\
Массив в сегменте стек. VLA-массив. Массив в сегменте данные. Массив в сегменте куча. Преемущества и недостатки создания каждого этих массивов.

\item \textbf{Создание своего динамического массива}\\
Создание своего динамического массива на основе массива в куче. Поля такого массива: указатель на данные в куче, размер (\texttt{size}) и вместимость (\texttt{capacity}). Чем размер отличается от вместимости? Функции для работы с нашим динимическим массивом:
\begin{itemize}
\item \texttt{init} -- инициализируем массив
\item \texttt{destroy} -- уничтожаем массив и освобождаем всю память
\item \texttt{get} -- возвращает \texttt{i}-й элемент
\item \texttt{set} -- устанавливаем \texttt{i}-й элемент
\item \texttt{reserve} -- изменяет вместимость динамического массива
\item \texttt{resize} -- изменяет размер динамического массива
\item \texttt{push\_back} -- добавляет один элемент в конец динамического массива
\end{itemize}
Как изменить тип элемента, который хранится в динамическом массиве?



\item \textbf{Макросы-константы}\\
Директива препроцессора \texttt{\#define}. Создание констант с помощью макросов.
Условная компиляция.  Директивы препроцессора \texttt{\#if}, \texttt{\#ifdef}, \texttt{\#ifndef}, \texttt{\#else}, \texttt{\#elif}, \texttt{\#endif} и оператор \texttt{defined}. Флаг \texttt{-D} компилятора gcc. Предопределённые макросы:
\texttt{\_\_FILE\_\_}, \texttt{\_\_LINE\_\_}, \texttt{\_\_DATE\_\_}, \texttt{\_\_TIME\_\_}, \texttt{\_\_VERSION\_\_}, \texttt{\_\_cplusplus}. Макросы для определение операционной системы: \texttt{\_WIN32}, \texttt{\_WIN64}, \texttt{\_\_linux\_\_}, \texttt{\_\_APPLE\_\_}, \texttt{\_\_ANDROID\_\_}. 

\item \textbf{Основы раздельной компиляции}\\
Директива препроцессора \texttt{\#include} и что конкретно она делает. Header-файлы.
Стражи включения. \texttt{\#pragma once}. Раздельная компиляция. Разделение кода программы на объявления и определения.
Стадии сборки программы (препроцессинг, компиляция, линковка). Флаг \texttt{-c} компилятора gcc.


\item \textbf{Функциональные макросы}\\
Функциональные макросы (function-like macros). Многострочные макросы. Типичные ошибки, которые могут возникнуть при работе с функциональными макросами. Использование оператора \texttt{do-while} в многострочных функциональных макросах. Операция stringification (\texttt{\#}). Операция concatenation (\texttt{\#\#}). Макрос \texttt{assert} из библиотеки \texttt{assert.h}. Написание макроса, аналогичного макросу \texttt{assert}. Флаг \texttt{-E} компилятора gcc.

\item \textbf{Макросы и динамический массив}\\
Использование макросов, для генерации кода динамического массива заданного типа.
\end{enumerate}


\iffalse
\newpage
\section*{Модуль 2}
\item  \textbf{Вычислительная сложность, $O(n)$ нотация}\\
Что такое $O(n)$, $\Omega(n)$ и $\Theta(n)$ нотации, математическое определение и смысл. Машина Тьюринга (детерминистическая и недетерминистическая). Классы сложности задач: $P$, $NP$, $PSPACE$, $EXPTIME$ и $EXPSPACE$.
Знать(или уметь выводить) сложности всех пройденных алгоритмов: алгоритм бинарного поиска в отсортированном массиве, алгоритмы сортировки (пузырьком, вставками, выбором, быстрая, сортировка слиянием, подсчётом, цифровая). Знать или уметь выводить сложности операций с пройденными структурами данных: поиск элемента по индексу в массиве и списке, вставка в массив(статический и динамический) и список; удаление из массива и списка; поиск по массиву и списку.

\item \textbf{Сортировка}\\
Парадигма разделяй и властвуй. Как возникает логарифмическая сложность в задачах, решаемых с помощью метода разделяй и властвуй. Алгоритм бинарного поиска в отсортированном массиве.
Сортировки пузырьком, вставками, выбором, быстрая, слиянием, подсчётом, цифровая и $Bogosort$. Вычислительные сложности всех этих алгоритмов. Уметь писать сортировку выбором, быструю сортировку и сортировку подсчётом. Cтандартная функция \texttt{qsort}. Функция компаратор \texttt{cmp}. Сортировка с помощью бинарного дерева поиска и с помощью бинарной кучи.


\item  \textbf{Абстрактные типы данных. Стек и очередь}\\
Структуры данных и абстрактный типы данных. Абстрактный тип данных Стек. Операции push и pop. Реализация стека на основе динамического массива. Динамическое выделение памяти для стека. Стратегии перевыделения памяти: аддитивная и мультипликативная. Абстрактный тип данных Очередь. Реализация очереди на основе динамического массива. Реализация стека и очереди на основе связного списка. Алгоритмические сложности операций со стеком.

\item \textbf{Связный список}\\
Связный список. Узел связного списка. Реализация связного списка на языке C. Функции нахождения длины списка, вставки элемента в начало/конец, удаления элемента из начала/конца, поиска в списке, обращения списка. Алгоритмические сложности операций со списком. Двусвязный список.


\item \textbf{Деревья}\\
Определение графа. Определение дерева. Бинарное дерево. Бинарное дерево поиска(bst). Высота дерева. Представление бинарного дерева в языке C. Операции поиска, добавления и удаления элемента в бинарном дереве поиска. Вычислительные сложности этих операций. Сбалансированное дерево. Два распространённых приёма для балансировки бинарных деревьев поиска (AVL-деревья и красно-чёрные деревья). Определение AVL-дерева. Операции вращения. Операции поиска, добавления и удаления элемента в AVL-дерево. Вычислительные сложности этих операций. Абстрактные типы данных множество (set) и словарь (dictionary).


\item \textbf{Хеш-таблица}\\
Что такое хеш-функция? Свойства хорошей хеш-функции. Что такое хеш-таблица? Добавление/удаление элемента в хеш-таблицу. Поиск элемента в хеш-таблице. Вычислительная сложность операций с хеш-таблицей. Абстрактные типы данных множество и словарь на основе хеш-таблицы. Чем различие между реализацие множества и словаря на основе сбалансированного дереве и на основе хеш-таблицы.




\item \textbf{Этапы компиляции}\\
Что такое файл исходного кода и исполняемый файл. Этап компиляции: препроцессинг, компиляция и линковка. Директивы препроцессора \texttt{\#include}, \texttt{\#define}, \texttt{\#ifdef}, \texttt{\#else} и \texttt{\#endif} и оператор \texttt{defined}. Компиляция программы с помощью \texttt{gcc}. Опции \texttt{gcc: -E, -c, -S}.


\item \textbf{* Очередь с приоритетом. Двоичная куча}\\
Хранение бинарных деревьев в массиве. Структура данных - двоичная куча. Операции добавления элемента в кучу. Операция удаления максимального элемента из кучи. Вычислительные сложности этих операций. Абстрактный тип данных - очередь с приоритетом. Реализация очереди с приоритетом с помощью двоичной кучи. Пирамидальная сортировка.

\item \textbf{* Динамическое программирование}\\
Суть динамического программирования. Задача о вычислении чисел Фибоначчи. Задача о поиске подмассива с максимальной суммой. Задача о наибольшей общей подпоследовательности. Задача о рюкзаке. 
\fi
\end{enumerate}



\newpage
\section*{Дополнительные материалы для подготовки:}
\begin{enumerate}
\item Керниган Ритчи Язык программирования C.\\
\hspace*{16pt} \href{https://lib.mipt.ru/book/266005/}{lib.mipt.ru/book/266005/}
\item Язык C и структуры данных в Йелле.\\ \hspace*{16pt} \href{http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html}{www.cs.yale.edu/homes/aspnes/classes/223/notes.html}
\end{enumerate}


\end{document}