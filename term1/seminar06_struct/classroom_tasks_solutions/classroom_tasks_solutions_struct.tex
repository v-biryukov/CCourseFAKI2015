\documentclass{article}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{amsmath} 
\usepackage{amsfonts}
\usepackage{upgreek}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{geometry}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{ccaption}
\usepackage{multicol}


\usepackage{listings}


\begin{document}
\pagestyle{plain}
\lstset{
  language=C,                % choose the language of the code
  basicstyle=\linespread{1.1}\ttfamily,
  columns=fixed,
  fontadjust=true,
  basewidth=0.5em,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray},
  stringstyle=\ttfamily\color{orange!50!black},
  showstringspaces=false,
  numbersep=5pt,
  numberstyle=\tiny\color{black},
  numberfirstline=true,
  stepnumber=1,                   % the step between two line-numbers.        
  numbersep=10pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
  showstringspaces=false,         % underline spaces within strings
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=true,         % sets if automatic breaks should only happen at whitespace
  xleftmargin=.2in,
  extendedchars=\true,
  keepspaces = true,
  frame=tlbr,
  framesep=8pt,
  framerule=0pt,
}
\lstset{literate=%
   *{0}{{{\color{red!20!violet}0}}}1
    {1}{{{\color{red!20!violet}1}}}1
    {2}{{{\color{red!20!violet}2}}}1
    {3}{{{\color{red!20!violet}3}}}1
    {4}{{{\color{red!20!violet}4}}}1
    {5}{{{\color{red!20!violet}5}}}1
    {6}{{{\color{red!20!violet}6}}}1
    {7}{{{\color{red!20!violet}7}}}1
    {8}{{{\color{red!20!violet}8}}}1
    {9}{{{\color{red!20!violet}9}}}1
}

\definecolor{solcolor}{RGB}{226,240,245}

\title{Семинар \#6: Структуры. Классные задачи.\vspace{-5ex}}\date{}\maketitle

\section*{Часть 1: Основы структур}

Структуры служат для объединения нескольких типов в один. В примере ниже был создан новый тип под названием \texttt{struct point}. Переменные этого типа будут содержать внутри себя 2 значения типа \texttt{float}.
\begin{lstlisting}
#include <stdio.h>

struct point {
    float x, y;
}; // <--------------------------- Не забудьте тут точку с запятой!

int main() {
    struct point a = {2.1, 4.3};
    a.x = 7.8;
    printf("(%f, %f)", a.x, a.y);
}
\end{lstlisting}

\subsection*{Операции со структурами}
\begin{enumerate}
\item При создании структуры её элементы можно инициализировать с помощью фигурных скобочек.
\begin{lstlisting}
struct point a = {2.1, 4.3};
\end{lstlisting}
Однако нельзя таким образом присваивать
\begin{lstlisting}
a = {5.6, 7.8}; // Ошибка, так можно только инициализировать
\end{lstlisting}
\item Доступ к элементу структуры осуществляется с помощью оператора точка
\begin{lstlisting}
a.x = 5.6;
a.y = 7.8;
\end{lstlisting}
\item Структуры можно присваивать друг другу. При этом происходит побайтовое копирование содержимого одной структуры в другую.
\begin{lstlisting}
struct point b;
b = a;
\end{lstlisting}
\end{enumerate}

\subsection*{Массив структур}
Структуры, как и обычные переменные, можно хранить в массивах. В примере ниже создан массив под названием \texttt{array}, содержащий в себе 2 точки.
\begin{lstlisting}
#include <stdio.h>
struct point {
    float x, y;
};
int main() {
    struct point array[2] = {{2.1, 4.3}, {7.0, 3.1}};
    array[1].x = 1.8;
    printf("(%f, %f)", array[0].x, array[0].y);
}
\end{lstlisting}

\subsection*{Задачи}
\begin{itemize}
\item Описать структуру \texttt{struct date}, с полями: \texttt{day}, \texttt{month} и \texttt{year}. 
\begin{lstlisting}[backgroundcolor = \color{solcolor}]
struct date {
    int day, month, year;
};
\end{lstlisting}
\item Объявить и инициализировать переменную \texttt{a} типа \texttt{struct date} в функции \texttt{main}.
\begin{lstlisting}[backgroundcolor = \color{solcolor}]
struct date {
    int day, month, year;
};
int main() {
    struct date a = {19, 10, 2021};
}
\end{lstlisting}
\item Объявить и инициализировать массив дат под названием \texttt{holidays} следующими значениями \texttt{31.12.2021}, \texttt{8.3.2022} и \texttt{9.5.2022}.
\begin{lstlisting}[backgroundcolor = \color{solcolor}]
struct date {
    int day, month, year;
};
int main() {
    struct date holidays[3] = {{31, 12, 2021}, {8, 3, 2022}, {9, 5, 2022}};
}
\end{lstlisting}
\item Напечатать содержимое массива \texttt{holidays} на экран с помощью цикла в следующем виде:
\begin{verbatim}
31.12.2021
08.03.2022
09.05.2022
\end{verbatim}

\begin{lstlisting}[backgroundcolor = \color{solcolor}]
#include <stdio.h>
struct date {
    int day, month, year;
};
int main() {
    struct date holidays[3] = {{31, 12, 2021}, {8, 3, 2022}, {9, 5, 2022}};
    for (int i = 0; i < 3; ++i) {
        printf("%02i.%02i.%i\n", holidays[i].day, holidays[i].month, holidays[i].year);
    }
}
\end{lstlisting}

\end{itemize}

\subsection*{Передача структуры в функцию}
Структуры можно передавать в функции и возвращать из функций также как и обычные переменных. При передаче в функцию происходит полное копирование структуры и функция работает уже с копией структуры. При возвращении из функции также происходит копирование. Для того чтобы избежать лишние копирования нужно передавать структуру по указателю (об этом -- в части 3).

\begin{lstlisting}
#include <stdio.h>

struct point {
    float x, y;
};
void print_point(struct point a) {
    printf("(%f, %f)", a.x, a.y);
}
struct point add_points(struct point a, struct point b) {
    struct point result;
    result.x = a.x + b.x;
    result.y = a.y + b.y;
    return result;
}
int main() {
    struct point a = {2.1, 4.3}, b = {6.7, 8.9};
    struct point c = add_points(a, b);
    print_point(c);
}
\end{lstlisting}

\subsection*{Задачи}
\begin{itemize}
\item Написать функцию \texttt{void print\_date(struct date a)} для печати этой структуры в формате \texttt{DD.MM.YYYY}. Используйте модификатор \texttt{\%02d}. Вызовите эту функцию из main, чтобы напечатать все содержимое \texttt{holidays}.

\begin{lstlisting}[backgroundcolor = \color{solcolor}]
#include <stdio.h>
struct date {
    int day, month, year;
};

void print_date(struct date a) {
    printf("%02i.%02i.%i\n", a.day, a.month, a.year);
}

int main() {
    struct date holidays[3] = {{31, 12, 2021}, {8, 3, 2022}, {9, 5, 2022}};
    for (int i = 0; i < 3; ++i) {
        print_date(holidays[i]);
    }
}
\end{lstlisting}

\newpage
\item Написать функцию \texttt{struct date pushkin\_birthday()} которая создаёт дату, соответствующую дню рождения А. С. Пушкина (6 июня 1799 года) и возвращает её. Протестируйте эту функцию в \texttt{main}.
\begin{lstlisting}[backgroundcolor = \color{solcolor}]
#include <stdio.h>
struct date {
    int day, month, year;
};

void print_date(struct date a) {
    printf("%02i.%02i.%i\n", a.day, a.month, a.year);
}

struct date pushkin_birthday() {
    struct date result = {6, 6, 1799};
    return result;
}

int main() {
    print_date(pushkin_birthday());
}
\end{lstlisting}

\item Написать функцию \texttt{struct date create\_date(int day, int month, int year)} которая создаёт дату, по трём переданным в функцию числам  и возвращает её. Протестируйте эту функцию в \texttt{main}.

\begin{lstlisting}[backgroundcolor = \color{solcolor}]
#include <stdio.h>
struct date {
    int day, month, year;
};

void print_date(struct date a) {
    printf("%02i.%02i.%i\n", a.day, a.month, a.year);
}

struct date create_date(int day, int month, int year) {
    struct date result = {day, month, year};
    return result;
}

int main() {
    print_date(create_date(5, 6, 2010));
}
\end{lstlisting}


\newpage
\item Написать функцию \texttt{struct date next\_day(struct date a)} которая увеличивает значение даты на один день и возвращает эту структуру. Для простоты не учитываем високосные года и считаем, что в феврале всегда 28 дней. Вызовите эту функцию из \texttt{main}, чтобы увеличить значение даты \texttt{holidays[0]} на 1 день.

\begin{lstlisting}[backgroundcolor = \color{solcolor}]
#include <stdio.h>
struct date {
    int day, month, year;
};

void print_date(struct date a) {
    printf("%02i.%02i.%i\n", a.day, a.month, a.year);
}

struct date pushkin_birthday() {
    struct date result = {6, 6, 1799};
    return result;
}

struct date next_day(struct date a) {
    int days[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    if (a.day == days[a.month - 1]) {
        a.month += 1;
        if (a.month == 13) {
            a.month = 1;
            a.year += 1;
        }
        a.day = 1;
    }
    else {
        a.day += 1;
    }
    return a;
}

int main() {
    struct date a = {31, 12, 2020};
    print_date(next_day(a));
}
\end{lstlisting}
\end{itemize}
\newpage
\section*{Часть 2: Структуры содержащие более сложные типы данных}
Структуры могут содержать в себе не только базовые типы данных, но и более сложные типы, такие как массивы (в том числе строки), указатели, а также другие структуры.\\
Пример программы, в которой описывается структура для удобной работы с объектами Книга (\texttt{struct book}).
\begin{lstlisting}
#include <stdio.h>
#include <string.h>

struct book {
    char title[50];
    int pages;
    float price;
};
void print_book(struct book b) {
    printf("Book info:\n");
    printf("Title: %s\nPages: %d\nPrice: %g\n\n", b.title, b.pages, b.price);
}
int main() {
    // Создаём книгу и печатаем её:
    struct book a = {"The Martian", 10, 550.0};
    print_book(a);
    
    // Меняем количество страниц книги и её название и снова печатаем её
    a.pages = 369;
    strcpy(a.title, "The Catcher in the Rye");
    print_book(a);
    
    // Пример работы с массивом структур
    struct book scifi_books[10] = {{"Dune", 300, 500.0}, {"Fahrenheit 451", 400, 700.0},
							 {"Day of the Triffids", 304, 450.0}};
    scifi_books[2].price = 2000.0;
    print_book(scifi_books[2]);
}
\end{lstlisting}


\subsection*{Задачи:}
\begin{itemize}

\item Описать структуру \texttt{struct movie} с полями: 
\begin{itemize}
\item \texttt{title} -- название фильма (строка длиной не более 50 символов).
\item \texttt{running\_time} -- длительность в минутах (\texttt{int})
\item \texttt{rating} -- оценка на Кинопоиске (\texttt{float})
\item \texttt{release\_date} -- дата выхода (используйте структуру \texttt{Date}).
\end{itemize}

\begin{lstlisting}[backgroundcolor = \color{solcolor}]
struct date {
    int day, month, year;
};
struct movie {
    char title[50];
    int running_time;
    float rating;
    struct date release_date;
};
\end{lstlisting}
\item Объявить переменную типа \texttt{struct movie} в функции \texttt{main} и инициализировать её следующими значениями:\\
\texttt{title -- ``Joker'', running\_time -- 122, rating -- 7.98, release\_date -- \{3, 10, 2019\}}.

\item В новых строках изменить рейтинг и месяц выхода фильма. Используйте оператор точка.
\begin{lstlisting}[backgroundcolor = \color{solcolor}]
struct date {
    int day, month, year;
};
struct movie {
    char title[50];
    int running_time;
    float rating;
    struct date release_date;
};
int main() {
    struct movie a = {"Joker", 122, 7.98, {3, 10, 2019}};
    a.rating += 1;
    a.release_date.month = 11;
}
\end{lstlisting}
\item Написать функцию \texttt{void print\_movie(struct movie m)} и вызвать её в функции \texttt{main}.
\item Написать функцию \texttt{struct movie get\_titanic()} которая будет возвращать структуру с полями \texttt{title -- ``Titanic'',  running\_time -- 194, rating -- 8.4, release\_date -- \{1, 11, 1997\}}. Вызовите эту функцию из \texttt{main} и напечатайте результат возвращаемого значения.
\begin{lstlisting}[backgroundcolor = \color{solcolor}]
#include <stdio.h>
struct date {
    int day, month, year;
};
struct movie {
    char title[50];
    int running_time;
    float rating;
    struct date release_date;
};

void print_date(struct date a) {
    printf("%02i.%02i.%i\n", a.day, a.month, a.year);
}
void print_movie(struct movie m) {
    printf("%s. Running time: %i. Rating: %.2f. Release Date: ", 
           m.title, m.running_time, m.rating);
    print_date(m.release_date);
}
struct movie get_titanic() {
    struct movie result = {"Titanic", 194, 8.4, {1, 11, 1997}};
    return result;
}
int main() {
    struct movie a = {"Joker", 122, 7.98, {3, 10, 2019}};
    struct movie b = get_titanic();
    print_movie(a);
    print_movie(b);
}
\end{lstlisting}


\item Объявить и инициализировать массив, содержащий 10 различных фильмов. Решение этой задачи есть ниже и в файле \texttt{movie\_array\_init.txt}. Просто скопируйте код.

\item В новой строке изменить день выхода фильма \texttt{Pulp Fiction} с 19-го мая на 21-е мая.
\item Написать функцию \texttt{print\_movie\_array(struct movie array[], int size)}, которая бы печатала массив структур \texttt{Movie} и вызвать её в функции \texttt{main()}.

\begin{lstlisting}[backgroundcolor = \color{solcolor}]
#include <stdio.h>
struct date {
    int day, month, year;
};
struct movie {
    char title[50];
    int running_time;
    float rating;
    struct date release_date;
};

void print_date(struct date a) {
    printf("%02i.%02i.%i", a.day, a.month, a.year);
}
void print_movie(struct movie m) {
    printf("%-30sRunning time: %4i. Rating: %.2f. Release Date: ", 
           m.title, m.running_time, m.rating);
    print_date(m.release_date);
}

void print_movies(struct movie array[], int size) {
    for (int i = 0; i < size; ++i) {
        print_movie(array[i]);
        printf("\n");
    }
}

int main() {
    struct movie array[10] = {{"The Godfather", 175, 8.735, {14, 3, 1972}},
                          {"The Shawshank Redemption", 142, 9.112, {10, 9, 1994}},
                          {"Fight Club", 175, 8.651, {10, 9, 1999}},
                          {"The Matrix", 131, 8.491, {24, 3, 1999}},
                          {"Pulp Fiction", 154, 8.620, {19, 5, 1994}},
                          {"Citizen Kane", 119, 7.826, {1, 5, 1941}},
                          {"A Clockwork Orange", 137, 7.959, {19, 12, 1971}},
                          {"2001: A Space Odyssey", 149, 7.988, {2, 4, 1968}},
                          {"Finding Nemo", 175, 7.862, {30, 05, 2003}},
                          {"Vzlomat blogerov", 90, 1.029, {10, 11, 2016}}};
    array[4].release_date.day = 21;
    print_movies(array, 10);
}
\end{lstlisting}
Тут был использован спецификатор для строки \texttt{\%-30s}, который означает, что нужно напечатать не менее 30 символов, а если символов будет меньше, то нужно добавить пробелов. \texttt{-} означает, что текст нужно выровнять по левому краю.


\newpage
\item Написать функцию, которая по массиву фильмов находит средний рейтинг. Протестируйте её в \texttt{main}.
\begin{lstlisting}[backgroundcolor = \color{solcolor}]
#include <stdio.h>
struct date {
    int day, month, year;
};
struct movie {
    char title[50];
    int running_time;
    float rating;
    struct date release_date;
};

void print_date(struct date a) {
    printf("%02i.%02i.%i", a.day, a.month, a.year);
}
void print_movie(struct movie m) {
    printf("%-30sRunning time: %4i. Rating: %.2f. Release Date: ", 
           m.title, m.running_time, m.rating);
    print_date(m.release_date);
}

void print_movies(struct movie array[], int size) {
    for (int i = 0; i < size; ++i) {
        print_movie(array[i]);
        printf("\n");
    }
}

float average_rating(struct movie array[], int size) {
    float sum_rating = 0;
    for (int i = 0; i < size; ++i) {
        sum_rating += array[i].rating;
    }
    return sum_rating / size;
}

int main() {
    struct movie array[10] = {{"The Godfather", 175, 8.735, {14, 3, 1972}},
                          {"The Shawshank Redemption", 142, 9.112, {10, 9, 1994}},
                          {"Fight Club", 175, 8.651, {10, 9, 1999}},
                          {"The Matrix", 131, 8.491, {24, 3, 1999}},
                          {"Pulp Fiction", 154, 8.620, {19, 5, 1994}},
                          {"Citizen Kane", 119, 7.826, {1, 5, 1941}},
                          {"A Clockwork Orange", 137, 7.959, {19, 12, 1971}},
                          {"2001: A Space Odyssey", 149, 7.988, {2, 4, 1968}},
                          {"Finding Nemo", 175, 7.862, {30, 05, 2003}},
                          {"Vzlomat blogerov", 90, 1.029, {10, 11, 2016}}};
    print_movies(array, 10);
    printf("Average rating = %.2f\n", average_rating(array, 10));
}
\end{lstlisting}

\newpage
\item \textbf{Сортировка структур:} Одна из простейших сортировок - это сортировка выбором:
\begin{lstlisting}
void selection_sort(int array[], int size) {
    for (int j = 0; j < size; j++){
        // Находим индекс минимального элемента на отрезке [j:n-1]
        int min_index = j;
        for (int i = j + 1; i < size; i++) {
            if (array[i] < array[min_index]) {
                min_index = i;
            }
        }
		
        // Меняем местами элемент номер j и минимальный элемент
        int temp = array[j];
        array[j] = array[min_index];
        array[min_index] = temp;
    }
}
\end{lstlisting}
Видоизмените эту сортировку так, чтобы она сортировала фильмы по рейтингу (от большего к меньшему). Помните, что структуры можно присваивать целиком, а не поэлементно.

\item \textbf{Сортировка по алфавиту:} Отсортируйте структуры по их названию в алфавитном порядке. Используйте функцию \texttt{strcmp} из \texttt{string.h}. Функция \texttt{strcmp(a, b)} возращает \texttt{0}, если строки равны, отрицательное число если строка \texttt{a} меньше, чем строка \texttt{b} и положительное число, если строка \texttt{a} больше, чем \texttt{b}. 

\begin{lstlisting}[backgroundcolor = \color{solcolor}]
#include <stdio.h>
#include <string.h>
struct date {
    int day, month, year;
};
struct movie {
    char title[50];
    int running_time;
    float rating;
    struct date release_date;
};

void print_date(struct date a) {
    printf("%02i.%02i.%i", a.day, a.month, a.year);
}
void print_movie(struct movie m) {
    printf("%-30sRunning time: %4i. Rating: %.2f. Release Date: ", 
           m.title, m.running_time, m.rating);
    print_date(m.release_date);
}

void print_movies(struct movie array[], int size) {
    for (int i = 0; i < size; ++i) {
        print_movie(array[i]);
        printf("\n");
    }
}

void sort_movies_by_rating(struct movie array[], int size) {
    for (int j = 0; j < size; j++){
        int min_index = j;
        for (int i = j + 1; i < size; i++) {
            if (array[i].rating > array[min_index].rating) {
                min_index = i;
            }
        }
        struct movie temp = array[j];
        array[j] = array[min_index];
        array[min_index] = temp;
    }
}

void sort_movies_by_title(struct movie array[], int size) {
    for (int j = 0; j < size; j++){
        int min_index = j;
        for (int i = j + 1; i < size; i++) {
            if (strcmp(array[i].title, array[min_index].title) < 0) {
                min_index = i;
            }
        }
        struct movie temp = array[j];
        array[j] = array[min_index];
        array[min_index] = temp;
    }
}

int main() {
    struct movie array[10] = {{"The Godfather", 175, 8.735, {14, 3, 1972}},
                          {"The Shawshank Redemption", 142, 9.112, {10, 9, 1994}},
                          {"Fight Club", 175, 8.651, {10, 9, 1999}},
                          {"The Matrix", 131, 8.491, {24, 3, 1999}},
                          {"Pulp Fiction", 154, 8.620, {19, 5, 1994}},
                          {"Citizen Kane", 119, 7.826, {1, 5, 1941}},
                          {"A Clockwork Orange", 137, 7.959, {19, 12, 1971}},
                          {"2001: A Space Odyssey", 149, 7.988, {2, 4, 1968}},
                          {"Finding Nemo", 175, 7.862, {30, 05, 2003}},
                          {"Vzlomat blogerov", 90, 1.029, {10, 11, 2016}}};
    printf("Before sorting:\n");
    print_movies(array, 10);
    
    sort_movies_by_rating(array, 10);
    
    printf("\nAfter sorting by rating:\n");
    print_movies(array, 10);
    
    sort_movies_by_title(array, 10);
    
    printf("\nAfter sorting by title:\n");
    print_movies(array, 10);
}
\end{lstlisting}

\end{itemize}


\newpage
\section*{Часть 3: Указатели на структуры:}
Указатель на структуру хранит адрес первого байта структуры. Для доступа к полям структуры по указателю нужно сначала этот указатель разыменовать, а потом использовать: \texttt{(*p).price}. Для удобства был введён оператор стрелочка \texttt{->}, который делает то же самое: \texttt{p->price}.
\begin{multicols}{2}
\begin{lstlisting}
#include <stdio.h>

struct book {
    char title[50];
    int pages;
    float price;
};
int main() {
    struct book a = {"The Martian",277,540};
    struct book* p = &a;
    // Три способа доступа к полю:
    a.price += 10;
    (*p).price += 10;
    p->price += 10;
}
\end{lstlisting}

\vfill\null
\columnbreak

\begin{center}
\includegraphics[scale=0.6]{../images/structpointer2.png}
\end{center}
\end{multicols}

\begin{itemize}
\item Измените первую букву поля \texttt{title} структуры, используя только указатель \texttt{p}.
\begin{lstlisting}[backgroundcolor = \color{solcolor}]
p->title[0] = 'A';
\end{lstlisting}
\end{itemize}

\subsection*{Передача по значению}
При обычной передаче в функцию всё содержимое копируется. Функция работает с копией.
\begin{lstlisting}
#include <stdio.h>
struct book {
    char title[50];
    int pages;
    float price;
};
void change(struct book a) {
    a.price += 10;
}
int main() {
    struct book a = {"The Martian",277,540};
    change(a);
}
\end{lstlisting}
\begin{center}
\includegraphics[scale=0.6]{../images/structpassbyvalue.png}
\end{center}


\subsection*{Передача по указателю}
При передаче в функцию по указателю копируется только указатель.
\begin{lstlisting}
#include <stdio.h>
struct book {
    char title[50];
    int pages;
    float price;
};
void change(struct book* p) {
    p->price += 10;
}
int main() {
    struct book a = {"The Martian",277,540};
    struct book* p = &a;
    change(p);
}
\end{lstlisting}
\begin{center}
\includegraphics[scale=0.6]{../images/structpassbypointer.png}
\end{center}
Такой способ передачи имее 2 преимущества:
\begin{enumerate}
\item Можно менять структуру внутри функции, и изменения будут действительны вне функции
\item Не приходится копировать структуры, поэтому программа работает быстрее.
\end{enumerate}

\subsection*{Передача по указателю на константу}
Иногда мы не хотим менять структуру внутри функции, но хотим чтобы ничего не копировалось. Тогда желательно использовать передачу по указателю
на константу.
\begin{lstlisting}
#include <stdio.h>
struct book {
    char title[50];
    int pages;
    float price;
};
void print_book_info(const struct book* p) {
    printf("Title: %s\nPages: %d\nPrice: %g\n\n", p->title, p->pages, p->price);
}
int main() {
    struct book a = {"The Martian",277,540};
    change(&a);
}
\end{lstlisting}

\begin{itemize}
\item Создать указатель \texttt{struct movie*} и присвоить ему адрес переменной типа \texttt{struct movie}.  Изменить поле \texttt{running\_time}, используя только указатель.  Используйте либо оператор точка (\texttt{.}) и оператор стрелочка (\texttt{->}).
\begin{lstlisting}[backgroundcolor = \color{solcolor}]
#include <stdio.h>
struct date {
    int day, month, year;
};
struct movie {
    char title[50];
    int running_time;
    float rating;
    struct date release_date;
};
void print_date(struct date a) {
    printf("%02i.%02i.%i", a.day, a.month, a.year);
}
void print_movie(struct movie m) {
    printf("%-20sRunning time: %4i. Rating: %.2f. Release Date: ", 
           m.title, m.running_time, m.rating);
    print_date(m.release_date);
    printf("\n");
}

int main() {
    struct movie m = {"The Godfather", 175, 8.735, {14, 3, 1972}};
    print_movie(m);
    
    struct movie* p = &m;
    (*p).running_time += 10;
    print_movie(m); 
    
    p->running_time += 10;
    print_movie(m); 
}
\end{lstlisting}

\item Написать функцию \texttt{void change\_rating(struct movie* pm, float new\_rating)} и вызвать её в функции \texttt{main}.
\begin{lstlisting}[backgroundcolor = \color{solcolor}]
void change_rating(struct movie* pm, float new_rating) {
    pm->rating = new_rating;
}
\end{lstlisting}

\item \textbf{Поиск лучшего фильма:} Написать функцию, которая принимает на вход массив фильмов и возвращает указатель на фильм с самым высоким рейтингом. Протестируйте в функции \texttt{main}.
\begin{lstlisting}[backgroundcolor = \color{solcolor}]
#include <stdio.h>
#include <string.h>
struct date {
    int day, month, year;
};
struct movie {
    char title[50];
    int running_time;
    float rating;
    struct date release_date;
};
void print_date(struct date a) {
    printf("%02i.%02i.%i", a.day, a.month, a.year);
}
void print_movie(struct movie m) {
    printf("%-30sRunning time: %4i. Rating: %.2f. Release Date: ", 
           m.title, m.running_time, m.rating);
    print_date(m.release_date);
}
struct movie* get_best_movie(struct movie array[], int size) {
    if (size == 0) 
        return NULL;
    struct movie* p_best_movie = &array[0];
    for (int i = 1; i < size; ++i) {
        if (array[i].rating > p_best_movie->rating) {
            p_best_movie = &array[i];
        }
    }
    return p_best_movie;
}
int main() {
    struct movie array[10] = {{"The Godfather", 175, 8.735, {14, 3, 1972}},
                          {"The Shawshank Redemption", 142, 9.112, {10, 9, 1994}},
                          {"Fight Club", 175, 8.651, {10, 9, 1999}},
                          {"The Matrix", 131, 8.491, {24, 3, 1999}},
                          {"Pulp Fiction", 154, 8.620, {19, 5, 1994}},
                          {"Citizen Kane", 119, 7.826, {1, 5, 1941}},
                          {"A Clockwork Orange", 137, 7.959, {19, 12, 1971}},
                          {"2001: A Space Odyssey", 149, 7.988, {2, 4, 1968}},
                          {"Finding Nemo", 175, 7.862, {30, 05, 2003}},
                          {"Vzlomat blogerov", 90, 1.029, {10, 11, 2016}}};
    print_movie(*get_best_movie(array, 10));
}
\end{lstlisting}

\item \textbf{Считывание:} Написать функцию \texttt{scan\_movie(struct movie* p)} и вызвать её в функции \texttt{main}. Функция должна считывать фильм  из стандартного входа с помощью \texttt{scanf} (каждое поле нужно считать отдельно).

\begin{lstlisting}[backgroundcolor = \color{solcolor}]
#include <stdio.h>
#include <string.h>
struct date {
    int day, month, year;
};
struct movie {
    char title[50];
    int running_time;
    float rating;
    struct date release_date;
};
void print_date(struct date a) {
    printf("%02i.%02i.%i", a.day, a.month, a.year);
}
void print_movie(struct movie m) {
    printf("%-20sRunning time: %4i. Rating: %.2f. Release Date: ", 
           m.title, m.running_time, m.rating);
    print_date(m.release_date);
}
void scan_movie(struct movie* p) {
    scanf("%[^\n]", p->title);
    scanf("%i", &p->running_time);
    scanf("%f", &p->rating);
    scanf("%i.%i.%i", &p->release_date.day, &p->release_date.month, &p->release_date.year);
}
int main() {
    struct movie a;
    scan_movie(&a);
    print_movie(a);
}

\end{lstlisting}

\end{itemize}

\end{document}