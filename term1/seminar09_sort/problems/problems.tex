\documentclass{article}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{amsmath} 
\usepackage{mathtext}
\usepackage{amsfonts}
\usepackage{upgreek}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{geometry}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{ccaption}
\usepackage{multicol}
%\setlength{\columnsep}{1.5cm}
%\setlength{\columnseprule}{0.2pt}


\begin{document}
\pagenumbering{gobble}

\newpage

\subsection*{Сложность алгоритмов}
\begin{enumerate}

\item Расположите следующие функции в порядке увеличения скорости роста при больших $n$:
\begin{multicols}{3}
\begin{enumerate}
\item $\log{n}$
\item $1$
\item $\sqrt{n}$
\item $n$
\item $1.01^n$
\item $\log{\log{n}}$
\item $\sqrt{2}^{log n}$
\item $(log (n))^{log(n)}$
\item $2^{2^n}$
\item $n!$
\item $n^n$
\item $n\log{n}$
\item $n^2$
\item $2^n$
\end{enumerate}
\end{multicols}

\item Отметьте все функции, равные $\Theta(n^2)$ и все функции, равные $O(n^2)$
\begin{multicols}{2}
\begin{itemize}
\item $1000 n^2$
\item $e^n$
\item $4 n^2 + 10 n + 50$
\item $\log{n}$
\item $\frac{n^3}{1000} + 5000 n^2$
\item $log(n^9 + n^5)$
\item $n\log{n}$
\item $n^3 / (1 + n)$
\end{itemize}
\end{multicols}


\item \textbf{} Чему равна алгоритмическая сложность следующих операций?
\begin{itemize}
\item Поиск элемента в массиве размера N
\item Добавление элемента в начало массива размера N
\item Сортировка пузырьком массива размера N
\item Быстрая сортировка массива размера N
\item Добавление элемента в стек размера N
\item Сложение матриц размера  $N \times N$
\item Простой алгоритм умножения матриц размера  $N \times N$
\item Следующий участок кода:
\begin{verbatim}
int sum = 0;
for (int i = 0; i < N; i++)
    for (int j = i+1; j < N; j++)
        for (int k = j+1; k < N; k++)
                sum++;
\end{verbatim}
\end{itemize}

\item Алиса и Боб любят игры и соревнования. И сейчас они готовы приступить к новой игре. Всего у них есть $X$ плиток шоколада. По правилам игры они могут есть этот шоколад по очереди(первой начинает Алиса). Известно, что Алиса съедает $7$ плиток шоколада за ход, а Боб -- $5$ плиток шоколада. Выигрывает тот, кто съест последнюю плитку. При заданном X, определить победителя. \\
Предложено 2 алгоритма решения этой задачи:
\begin{itemize}
\item Плохой: Вычитаем сначала $7$, затем $5$ и так до тех пор пока не дойдём до $0$ (или отрицательного числа). Чему равна сложность данного решения?
\item Хороший: Сначала находим остаток от деления X на 12. В зависимости от остатка определяем победителя. Чему равна сложность данного решения?
\end{itemize}
\end{enumerate}

\newpage
\subsection*{Сортировки}
\begin{enumerate}
\item Создайте массив со следующими элементами: \{163, 624, 7345, 545, 41, 78, 5, 536, 962, 1579\}
\item \textbf{Печать массива:} Написать функцию \texttt{print\_array(int n, int arr[])}
\item \textbf{Сортировка выбором:} Написать функцию сортировки выбором \texttt{void selection\_sort(int n, int arr[])}.\\
\texttt{arr} -- массив чисел, которые нужно отсортировать, \texttt{n} -- количество чисел в этом массиве.
Будем обозначать подмассивы так: arr[k:m] -- подмассив массива arr с элементами под номерами от k до m. Таким образом, весь массив можно обозначить как arr[0:n-1]. \\

Алгоритм сортировки выбором:
\begin{itemize}
\item Найти минимальный элемент в массиве.
\item Поменять местами минимальный элемент и первый элемент массива.
\item Повторить эти операции для подмассива arr[1:n-1], затем для подмассива arr[2:n-1] и т.д.
\end{itemize}
\item \textbf{Рекурсивная сортировка выбором:} Написать рекурсивную функцию сортировки выбором \\
\texttt{void rec\_selection\_sort(int start, int n, int arr[])}.\\
\texttt{arr} -- массив чисел, которые нужно отсортировать, 
\texttt{n} -- количество чисел в массиве arr,
\texttt{start} -- начальный индекс подмассива в массиве arr.\\
\item \textbf{Быстрая сортировка:} Написать рекурсивную функцию быстрой сортировки\\ \texttt{void quick\_sort(int arr[], int lo, int hi)},\\
которая будет сортировать подмассив \texttt{arr[lo:hi]} массива arr.

Алгоритм быстрой сортировки:
\begin{itemize}
\item Если \texttt{lo < hi}:
	\begin{enumerate}
	\item Выбираем последний элемент подмассива в качестве опорного. Сохраняем это значение в переменной \texttt{pivot}.
	\item Вводим переменные-счётчики \texttt{i = lo}
	\item Бежим по массиву, используя новую переменную счётчик j, и, для каждого элемента, который не больше опорного, меняем i-й и j-й элементы. После каждого обмена увеличиваем i на 1.
	\item Меняем i-й элемент и опорный, так как мы хотим, чтобы опорный элемент разделял 2 подмассива.
	\item Рекурсивно вызываем функцию quick\_sort() для каждого из подмассивов.
	\end{enumerate}
\end{itemize}
\end{enumerate}

\newpage
\subsection*{Стандартная функция qsort()}

Пример использования функции qsort():
\begin{verbatim}
#include <stdio.h>      /* printf */
#include <stdlib.h>     /* qsort */

int cmp(const void* a, const void* b)
{
    int* pa = (int*)a;
    int* pb = (int*)b;
    return ( *pa - *pb );
}

int main ()
{
    int arr[] = {163, 624, 7345, 545, 41, 78, 5, 536, 962, 1579};
    qsort(arr, 10, sizeof(int), cmp);
   
    print_array(10, arr);
}
\end{verbatim}
\subsubsection*{Задачи:}
\begin{enumerate}
\item Отсортировать числа массива \texttt{arr} по убыванию.
\item Отсортировать числа массива \texttt{arr} по возрастанию последней цифры.
\item Отсортировать числа массива \texttt{arr} по первой цифре числа.
\item Описать структуру \texttt{Movie} с полями \texttt{title}(название -- строка), \texttt{year}(год выхода -- целое число), \texttt{rating}(рейтинг на кинопоиске -- вещественное число). Создать массив из 6-ти таких структур. Написать отдельную функцию для печати такого массива на экран.
\item Отсортировать массив фильмов по убыванию рейтинга. 
\item Отсортировать массив фильмов по возрастанию года выхода. 
\item Интерпретируем значения массива \texttt{arr}, как значения некоторых углов в градусах. Отсортировать числа по возрастанию косинусов соответствующих углов.
\item Отсортировать числа массива \texttt{arr} следующим образом: сначала четные числа по возрастанию, затем нечётные по убыванию.

\end{enumerate}
\end{document}