\documentclass{article}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{amsmath} 
\usepackage{amsfonts}
\usepackage{upgreek}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{geometry}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{ccaption}
\usepackage{multicol}

\usepackage{listings}
%\setlength{\columnsep}{1.5cm}
%\setlength{\columnseprule}{0.2pt}


\begin{document}
\pagenumbering{gobble}

\lstset{
  language=C,                % choose the language of the code
  basicstyle=\linespread{1.1}\ttfamily,
  columns=fixed,
  fontadjust=true,
  basewidth=0.5em,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray},
  stringstyle=\ttfamily\color{orange!50!black},
  showstringspaces=false,
  %numbers=false,                   % where to put the line-numbers
  numbersep=5pt,
  numberstyle=\tiny\color{black},
  numberfirstline=true,
  stepnumber=1,                   % the step between two line-numbers.        
  numbersep=10pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
  showstringspaces=false,         % underline spaces within strings
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=true,         % sets if automatic breaks should only happen at whitespace
  xleftmargin=.2in,
  extendedchars=\true,
  keepspaces = true,
}
\lstset{literate=%
   *{0}{{{\color{red!20!violet}0}}}1
    {1}{{{\color{red!20!violet}1}}}1
    {2}{{{\color{red!20!violet}2}}}1
    {3}{{{\color{red!20!violet}3}}}1
    {4}{{{\color{red!20!violet}4}}}1
    {5}{{{\color{red!20!violet}5}}}1
    {6}{{{\color{red!20!violet}6}}}1
    {7}{{{\color{red!20!violet}7}}}1
    {8}{{{\color{red!20!violet}8}}}1
    {9}{{{\color{red!20!violet}9}}}1
}

\renewcommand{\thesubsection}{\arabic{subsection}}
\makeatletter
\def\@seccntformat#1{\@ifundefined{#1@cntformat}%
   {\csname the#1\endcsname\quad}%    default
   {\csname #1@cntformat\endcsname}}% enable individual control
\newcommand\section@cntformat{}     % section level 
\newcommand\subsection@cntformat{Задача \thesubsection.\space} % subsection level
\newcommand\subsubsection@cntformat{\thesubsubsection.\space} % subsubsection level
\makeatother

\title{Семинар \#2: Массивы. Домашнее задание. \vspace{-5ex}}\date{}\maketitle

\subsection{Операции над массивом}
Во всех подзадачах этой задачи вам нужно изменить массив \texttt{a} и, возможно, размер \texttt{n} между считыванием массива и его печатью. Каждая программа должна иметь такой вид:
\begin{lstlisting}
#include <stdio.h>
int main() 
{
    int a[1000];
    int n;
    scanf("%i", &n);
    for (int i = 0; i < n; ++i)
        scanf("%i", &a[i]);

    // ||||| Ваш код между считыванием и печатью массива  |||||
    
    
    // ||||||||||||||||||||||||||||||||||||||||||||||||||||||||
    for (int i = 0; i < n; ++i)
        printf("%i ", a[i]);

    printf("\n");
}
\end{lstlisting}
Внутри вашего кода нужно считать дополнительные данные и изменить массив и переменную \texttt{n}.

\begin{enumerate}
\item \textbf{Удвоение массива:} Нужно увеличить массив \texttt{a} в 2 раза, заполнив новую часть копией массива \texttt{a}. Предполагается, что количество места в массиве (\texttt{1000}) больше чем \texttt{2n}, то есть места хватит. Не забудьте изменить переменную \texttt{n}.
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{4} & \texttt{0 1 2 3 0 1 2 3}  \\  
 \texttt{0 1 2 3} &  \\ \hline
 \texttt{3} & \texttt{6 4 3 6 4 3}  \\
 \texttt{6 4 3} &  \\  
\end{tabular}
\end{center}

\item \textbf{Вставка:} На вход подаётся массив, новый элемент массива и индекс -- положение в массиве, после которого нужно вставить элемент. Чтобы освободить место в массиве нужно передвинуть часть элементов вправо. Предполагается, что количество места в массиве (\texttt{1000}) больше чем \texttt{n}, то есть места на 1 элемент хватит. Будьте осторожны, не перепишите элементы массива при их перемещении. Не забудьте изменить переменную \texttt{n}.
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{6} & \texttt{0 1 2 9 3 4 5}  \\  
 \texttt{0 1 2 3 4 5} &  \\ 
 \texttt{9 2} &   \\ \hline
 \texttt{2} & \texttt{1 5 4}  \\  
 \texttt{1 5} &  \\ 
 \texttt{4 1} &   \\
\end{tabular}
\end{center}

\item \textbf{Удаление:} На вход подаётся массив и индекс элемента, который нужно удалить. При этом понадобится передвинуть часть элементов влево.
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{6} & \texttt{0 1 2 4 5}  \\  
 \texttt{0 1 2 3 4 5} &  \\ 
 \texttt{3} &   \\ \hline
 \texttt{2} & \texttt{5}  \\  
 \texttt{1 5} &  \\ 
 \texttt{0} &   \\
\end{tabular}
\end{center}

\item \textbf{Удаление подмассива:} На вход подаётся массив и подмассив(2 индекса). Нужно удалить этот подмассив из массива. Постарайтесь написать как можно более эффективный код. Например, каждый элемент нужно переместить только 1 раз.
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{6} & \texttt{0 4 5}  \\  
 \texttt{0 1 2 3 4 5} &  \\ 
 \texttt{1 4} &   \\ \hline
 \texttt{9} & \texttt{2 1}  \\  
 \texttt{9 8 7 6 5 4 3 2 1} &  \\ 
 \texttt{0 7} &   \\
\end{tabular}
\end{center}
\item \textbf{Удаление отрицательных элементов:} Удалите все отрицательные элементы из массива. Постарайтесь написать как можно более эффективный код. Например, каждый элемент нужно переместить только 1 раз.
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{6} & \texttt{0 2 5}  \\  
 \texttt{0 -1 2 -3 -4 5} &  \\ \hline
 \texttt{2} & \texttt{9}  \\  
 \texttt{9 -5} &  \\ 
\end{tabular}
\end{center}
\item \textbf{Разделение на чётные/нечётные:} Переставьте элементы массива \texttt{a} так, чтобы сначала в нём шли нечётные элементы, а потом чётные. Причём порядок следования внутри чётной или нечётной части не важен. Эту задачу можно решить с использованием дополнительных массивов, а можно и без них.
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{7} & \texttt{1 3 5 0 4 2 6}  \\  
 \texttt{0 1 2 3 4 5 6} & \\ \hline
 \texttt{9} & \texttt{9 7 5 3 1 8 2 4 6}  \\  
 \texttt{9 8 7 6 5 4 3 2 1} &  \\ \hline
 \texttt{2} & \texttt{1 2}  \\  
 \texttt{2 1} &  \\
\end{tabular}
\end{center}

\item \textbf{Раздвоение:} Увеличьте массив в 2 раза, раздвоив каждый элемент. Постарайтесь написать более оптимальный код без использования дополнительного массива.
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{6} & \texttt{0 0 1 1 2 2 3 3 4 4 5 5}  \\  
 \texttt{0 1 2 3 4 5} & \\ \hline
 \texttt{1} & \texttt{1 1}  \\  
 \texttt{1} &  \\
\end{tabular}
\end{center}
\item \textbf{Циклический сдвиг:} На вход подаётся массив и целое положительное число \texttt{k} нужно циклически сдвинуть массив на \texttt{k} элементов вправо.
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{6} & \texttt{4 5 0 1 2 3}  \\  
 \texttt{0 1 2 3 4 5} & \\
 \texttt{2} & \\ \hline
 \texttt{6} & \texttt{1 2 3 4 5 0}  \\  
 \texttt{0 1 2 3 4 5} & \\
 \texttt{5} & \\ 
\end{tabular}
\end{center}
\textit{Подсказка:} Новое положение \texttt{i}-го элемента в массиве будет задаваться формулой \texttt{(i + k) \% n}. Эту задачу проще всего решить с использованием дополнительного массива, но можно и без него.
\end{enumerate}



\section*{Бинарный поиск на отсортированном массиве}
Если известно, что массив уже отсортирован, то многие задачи на таком массиве можно решить гораздо проще и/или эффективней. Например, просто найти минимум, максимум и медианное значение. Одной из задач, которая быстрее решается на отсортированном массиве -- это задача поиска элемента в массиве. Если массив отсортирован, то решить эту задачу можно гораздо быстрее чем простой обход всех элементов. \\

Предположим, что массив отсортирован по возрастанию и надо найти элемент \texttt{x} в этом массиве или понять, что такого элемента в массиве не существует. Для этого мы мысленно разделим массив на  2 части:
\begin{enumerate}
\item Элементы, которые меньше, чем \texttt{x}
\item Элементы, которые больше или равны \texttt{x}
\end{enumerate}

Затем введём две переменные-индекса \texttt{l} и \texttt{r}. В начале работы алгоритма индекс \texttt{l} будет хранить индекс фиктивного элемента, находящегося до первого (то есть \texttt{l = -1}), а индекс \texttt{r} будет хранить индекс фиктивного элемента, находящимся после последнего (то есть \texttt{r = n}). 

На каждом шаге алгоритма мы будем брать середину между индексами \texttt{l} и \texttt{r} и передвигать к этой середине или индекс \texttt{l} или индекс \texttt{r}. При этом при изменении индексов должны соблюдаться условия:
\begin{verbatim}
a[l] < x
a[r] >= x
\end{verbatim}

Алгоритм закончится тогда, когда разница между индексами не станет равным 1, то есть не станет \\
\texttt{r == l + 1}. И так как \texttt{a[l] < x} и \texttt{a[r] >= x}, то если элемент \texttt{x} в массиве существует, то его индекс равен \texttt{r}.



Код для поиска в отсортированном массиве бинарным поиском:
\begin{lstlisting}
#include <stdio.h>

int main() 
{
    int n;
    int a[1000];
    scanf("%i", &n);
    for (int i = 0; i < n; ++i)
        scanf("%i", &a[i]);
        
    int x;
    scanf("%i", &x);
    
    int l = -1, r = n;
    while (r > l + 1) 
    {
        int mid = (l + r) / 2;
        
        if (a[mid] >= x)
            r = mid;
        else 
            l = mid;
    }
    
    if (r < n && a[r] == x)
        printf("Element found! Index = %i\n", r);
    else
        printf("Element not found!");
}

\end{lstlisting}

\subsection{Нижняя граница}
Пусть дан массив и некоторое число \texttt{x}. Нижняя граница -- это индекс первого элемент, который больше или равен \texttt{x}. Напишите эффективную программу, которая ищет нижнюю границу на отсортированном массиве. Если такого элемента нет, то нужно вернуть \texttt{n}.

\begin{multicols}{3}
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{7} & \texttt{3}  \\  
 \texttt{1 1 1 2 2 5 6} & \\
 \texttt{2} & \\ \hline
 \texttt{7} & \texttt{4}  \\  
 \texttt{0 1 1 2 6 6 9} & \\
 \texttt{3} & \\ 
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{5} & \texttt{4}  \\  
 \texttt{1 2 3 4 5} & \\
 \texttt{5} & \\ \hline
 \texttt{5} & \texttt{0}  \\  
 \texttt{1 1 1 1 1} & \\
 \texttt{1} & \\
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{3} & \texttt{0}  \\  
 \texttt{2 2 6} & \\
 \texttt{1} & \\ \hline
 \texttt{3} & \texttt{3}  \\  
 \texttt{2 2 6} & \\
 \texttt{9} & \\
\end{tabular}
\end{center}
\end{multicols}


\iffalse
\subsection{Поиск пика}
Пусть дан массив. Известно, что у этого массива и первые \texttt{k >= 0} элементов строго возрастают, а остальные -- строго убывают. Напишите эффективную программу, которая будет искать индекс пика (максимального элемента) в этом массиве. Используйте
бинарный поиск, чтобы сделать алгоритм поиска пика более эффективным.

\begin{multicols}{3}
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{7} & \texttt{3}  \\  
 \texttt{1 2 3 4 3 2 1} & \\\hline
 \texttt{7} & \texttt{1}  \\  
 \texttt{1 9 8 6 4 3 1} & \\
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{5} & \texttt{4}  \\  
 \texttt{1 2 3 4 5} & \\ \hline
 \texttt{5} & \texttt{3}  \\  
 \texttt{1 2 3 9 1} & \\
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{3} & \texttt{1}  \\  
 \texttt{1 2 1} & \\ \hline
 \texttt{1} & \texttt{0}  \\  
 \texttt{5} & \\
\end{tabular}
\end{center}
\end{multicols}
\fi

\newpage
\section*{Матрицы}
\subsection{Сумма столбцов}
На вход поступают размеры матрицы \texttt{n} и \texttt{m} и элементы матрицы. Нужно найти сумму элементов в каждом столбце. Для этой задачи не нужно использовать двумерный массив, достаточно будет одномерного.
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{3 4} &    \texttt{14 15 16 12}  \\ 
 \texttt{1 2 3 6} &  \\
 \texttt{6 5 4 2} &  \\ 
 \texttt{7 8 9 4} &  \\ 
\end{tabular}
\end{center}



\subsection{Сортировка столбцов}
На вход поступают размеры матрица \texttt{n} и \texttt{m} и элементы матрицы. Нужно отсортировать элементы в каждом столбце.
\begin{multicols}{2}
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{5 3} &    \texttt{1 1 1} \\ 
 \texttt{8 1 9} &  \texttt{2 2 3}\\
 \texttt{2 5 1} &  \texttt{4 2 7}\\ 
 \texttt{7 5 7} &  \texttt{7 5 7}\\ 
 \texttt{4 2 3} &  \texttt{8 5 9}\\ 
 \texttt{1 2 7} &  \\ 
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{2 6} &          \texttt{5 2 1 3 1 2} \\ 
 \texttt{6 2 8 3 2 4} &  \texttt{6 4 8 5 2 4}\\
 \texttt{5 4 1 5 1 2} & \\ 
\end{tabular}
\end{center}
\end{multicols}



\subsection{Умножение матриц}
На вход поступает число \texttt{n} и две квадратных матрицы размера \texttt{nxn}. Нужно перемножить эти матрицы и напечатать результат. Формула перемножения матриц:
$$
C_{ij} = \sum\limits_{k=0}^{n-1} A_{ik} \cdot B_{kj}
$$.
\begin{multicols}{2}
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{3} &     \texttt{21 30 130}  \\ 
 \texttt{7 7 2} & \texttt{-6 21 82}  \\
 \texttt{1 8 3} & \texttt{48 12 -1}  \\ 
 \texttt{2 1 6} &  \\ 
 \texttt{} &  \\
 \texttt{5 2 9} &  \\
 \texttt{-4 2 11} &  \\ 
 \texttt{7 1 -5} &  \\ 
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{3} &     \texttt{55 60 70}  \\ 
 \texttt{5 2 9} & \texttt{-4 -1 64}  \\
 \texttt{-4 2 11} & \texttt{40 52 -13}  \\ 
 \texttt{7 1 -5} &  \\ 
 \texttt{} &  \\
 \texttt{7 7 2} &  \\
 \texttt{1 8 3} &  \\ 
 \texttt{2 1 6} &  \\ 
\end{tabular}
\end{center}
\end{multicols}
 
 
\newpage 
\section*{Работа с файлами} 
\subsection{Сортировка по сумме цифр}
В файле \texttt{numbers.txt} хранится 10000 чисел. Считайте эти числа и отсортируйте по сумме цифр. То есть число, у которого сумма цифр минимальна должно идти первым. Сохраните результат в файле \texttt{sorted.txt}. Для считывания из файла и печати в файл используйте метод перенаправления потока.

\subsection{Умножение матриц из файла}
В файлах \texttt{matA.txt} и \texttt{matB.txt} сохранены матрицы \texttt{10x10}. Считайте эти матрицы, перемножьте их и сохраните в файле \texttt{matC.txt}. Считать их можно методом перенаправления потока из файла \texttt{combinedAB.txt}. В результате должна получиться такая матрица:
\begin{center}
$
\begin{pmatrix}
259 & -15 & 237 & 257 &  231 &  67  & 237  & -64  & 152  & 363 \\
555 & 233 & 539 & 188 &  356 &  325 &  423 &  -47 &  123 &  387 \\
497 & 512 & 572 & 95  & 619  & 155  & 414  & 207  & 203  & 217 \\
455 & 280 & 675 & 354 &  664 &  346 &  483 &  177 &  168 &  404 \\
264 & 182 & 272 & 290 &  474 &  -33 &  234 &  99  & 379  & 156 \\
272 & 180 & 469 & 286 &  326 &  282 &  325 &  215 &  195 &  231 \\
421 & 363 & 475 & 506 &  359 &  481 &  468 &  101 &  325 &  328 \\
384 & 218 & 567 & 395 &  475 &  488 &  361 &  168 &  291 &  298 \\
387 & 297 & 480 & 170 &  318 &  423 &  483 &  10  & -17  & 406 \\
193 & 241 & 486 & 38  & 403  & 146  & 286  & 326  & 212  & 172 \\
\end{pmatrix}
$
\end{center}
Для считывания из файла и печати в файл используйте метод перенаправления потока.
\end{document}