#include <stdio.h>
#include <stdlib.h>
#include <string.h>


// Это структура, описывающая координаты(или точки) на плоскости
// Обратите внимание, что здесь был использован оператор typedef
// Так что, теперь везде, для обозначения этого типа можно писать Coord вместо struct Cd
typedef  struct Cd{
	int x,y;
}Coord;


// Это структура, описывающая треугольник на плоскости
// lin -- это массив из трех структур типа Coord
// size -- это массив из квадратов сторон треугольника, введён для удобства
// Также, был использован оператор typedef, так что для обозначения типа треугольника можно писать просто Triangle
typedef struct Tr{
	Coord lin[3];
	int size[3];
}Triangle;


// Функция getCoord, введена для удобства считывания координат из стандартного потока
// Нужно обязательно запомнить синтаксис прототипа и определения функции
// Прототип функции был написан в тексте задания и выглядел примерно так:
//            void getCoord(Coord *); или так: void getCoord(Coord * a);
// Для прототипа функции не нужно тело функции (которое находится в фиг. скобках) и в конце прототипа ставится запятая
// Также в прототипе функции может быть опущено названия переменных
// Прототипы используются, если вам нужно просто сказать, что такая функция есть и не описывать её
// Если же вам нужно описать функцию, то обязательно наличие тела функции и имен параметров(в данном случае это 1 параметр -- a)

// Также в этой функции использовался в качестве параметра не сама структура Coord, a указатель на нее
// Указатель на любой тип объявляется как: <имя типа> *
// Например: int * pi; float * pf; Coord * a;
// Чтобы получить доступ к полю структуры, используя структуру нужно использовать оператор 'точка': .
// Чтобы получить доступ к полю структуры, используя указатель на структуру нужно использовать оператор: ->
void getCoord(Coord * a)
{
	scanf("%d %d", &a->x, &a->y); // Не забывайте &, так как функция scanf также принимает указатель, а не саму переменную
}

// Функция printCoord(), введена для удобства печатания координат в стандартный поток
// Также, как и предыдущая, эта функция ничего не возвращает, поэтому вместо типа используется ключевое слово void
void printCoord(Coord a)
{
	printf("(%d,%d)", a.x, a.y);
}

// Функция getDataTri, считывает тройку координат(6 чисел) из стандартного входа
// 		выделяет память на 1 структуру Triangle
//		заполняет ее
//		и возвращает (Triangle *) -- указатель на структуру Triangle
Triangle * getDataTri()
{
	// Сначала объявим массив из координат и считаем все 3 координаты используя уже написанную функцию getCoord
	Coord a[3];
	getCoord(&a[0]);
	getCoord(&a[1]);
	getCoord(&a[2]);

	// Теперь сложная часть(но эта часть была написана в тексте задания):
	// 		Triangle * p -- объявляем указатель на структуру
	// 		malloc(n) -- функция, которая выделяет кусок памяти размером n байт и возвращает указатель на нее
	// 		Нам нужно памяти на одну структуру Triangle, поэтому n = sizeof(Triangle)
	// 		sizeof мы проходили на 1-м семинаре, он возвращает размер переданного типа(или переменной) в байтах
	// 		malloc возвращает указатель типа (void *)
	//		чтобы превратить такой указатель в нужный нам указатель (Triangle *), нужно написать перед функцией (Triangle *)
	Triangle * p = (Triangle*)malloc(sizeof(Triangle));
	// Таким образом был выделен кусок памяти для хранения одной структуры Triangle; указатель p указывает на этот кусок

	// Теперь нам нужно задать поля новой структуры: Поля p->lin и p->size
	// 1) поле p->lin -- массив из трёх элементов -- координат треугольника
	// 		такой массив у нас уже есть(Coord a[3]), он был считан в начале функции 
	// 		так что нужно просто скопировать массив a в массив p->lin
	// 		это делается с помощью стандартной функции memcpy(куда скопировать, откуда, размер в байтах)
    memcpy(p->lin, a, sizeof(Coord)*3);


    // 2) поле p->size -- это массив из квадратов сторон треугольника
    // 		находим их обычным способом через координаты вершин

    p->size[0] = (p->lin[0].x - p->lin[1].x)*(p->lin[0].x - p->lin[1].x) + (p->lin[0].y - p->lin[1].y)*(p->lin[0].y - p->lin[1].y);
    p->size[1] = (p->lin[1].x - p->lin[2].x)*(p->lin[1].x - p->lin[2].x) + (p->lin[1].y - p->lin[2].y)*(p->lin[1].y - p->lin[2].y);
    p->size[2] = (p->lin[2].x - p->lin[0].x)*(p->lin[2].x - p->lin[0].x) + (p->lin[2].y - p->lin[0].y)*(p->lin[2].y - p->lin[0].y);


    // Возвращаем (Triangle *) p
    return p;
}

// Функция printCoord(), введена для удобства печатания координат в стандартный поток
// Печатаем координаты используя уже созданную функцию printCoord
void printTri(Triangle *a)
{
	printCoord(a->lin[0]);
	printf(" ");
	printCoord(a->lin[1]);
	printf(" ");
	printCoord(a->lin[2]);
	printf("\n");
}

// cmpTri -- функция, которая сравнивает равны ли треугольники
// на вход принимаются 2 указателя на треугольник a и b
// a->size -- квадраты сторон 1-го треугольника
// и->size -- квадраты сторон 2-го треугольника
// возвращает 1, если треугольники равны и 0, если не равны
int cmpTri(const Triangle* a, const Triangle* b)
{
	// Нужно сравнить все стороны на равенство
	// Так как порядок следования сторон не фиксирован нужно проверить все 6 комбинаций
	int comp1 = (a->size[0] == b->size[0]) && (a->size[1] == b->size[1]) && (a->size[2] == b->size[2]);
	int comp2 = (a->size[0] == b->size[0]) && (a->size[1] == b->size[2]) && (a->size[2] == b->size[1]);

	int comp3 = (a->size[0] == b->size[1]) && (a->size[1] == b->size[0]) && (a->size[2] == b->size[2]);
	int comp4 = (a->size[0] == b->size[1]) && (a->size[1] == b->size[2]) && (a->size[2] == b->size[0]);

	int comp5 = (a->size[0] == b->size[2]) && (a->size[1] == b->size[0]) && (a->size[2] == b->size[1]);
	int comp6 = (a->size[0] == b->size[2]) && (a->size[1] == b->size[1]) && (a->size[2] == b->size[0]);
	return comp1 || comp2 || comp3 || comp4 || comp5 || comp6;
}


// deleteTri -- функция, которая освобождает кусок памяти, которую мы выделили в функции getDataTri
// всю память, которая была выделена с помощью malloc нужно обязательно освободить с помощью free
// иначе эта память останется заблокированной
// Такая ситуация называется утечка памяти(memory leak)
int deleteTri(Triangle * a)
{
	free(a); // free( указатель на память, которая была выделена с помощью malloc )
	return 0;
}

int main()
{
	// Объявляем 2 указателя на треугольники и задаем их с помощью getDataTri
	Triangle* pt1 = getDataTri();
	Triangle* pt2 = getDataTri();
	// Сравниваем их и печатаем результат
	int is_equal = cmpTri(pt1, pt2);
	if (is_equal)
		printf("Triangles are equal\n");
	else
		printf("Triangles aren't equal\n");
	// Не забываем освободить память
	deleteTri(pt1);
	deleteTri(pt2);
	return 0;
}
