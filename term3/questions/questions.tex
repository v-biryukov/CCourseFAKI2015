\documentclass{article}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{amsmath} 
\usepackage{amsfonts}
\usepackage{upgreek}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{geometry}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{ccaption}



\begin{document}
\pagenumbering{gobble}

\section*{Теория:}
\begin{enumerate}


\item \textbf{Параллелизм и конкурентность.}\\
Что такое параллелизм и что такое конкурентность? Что такое процесс и что такое поток? Организация параллелизма с использование процессов и с использованием потоков. В чём преемущества и недостатки этих подходов. Зачем нужен параллелизм?

\item \textbf{Потоки. Класс \texttt{std::thread}}\\
Что такое поток? Создание нового потока в языке \texttt{C++} с использованием объекта класса \texttt{std::thread}. Методы \texttt{join} и \texttt{detach}. Что произойдёт если выбросится исключение (в новом потоке, или в потоке, который создаёт новый поток)? Передача аргументов в функцию потока. Возврат данных из нового потока. Передача владения потоком. Создание произвольного количества потоков. Идентификация потоков.


\item \textbf{Состояние гонки и мьютексы.}\\
Что такое разделяемые данные? Что такое состояние гонки (race condition)? Проблематичные и безобидные состояния гонки. Что такое гонка данных (data race) и к чему она приводит? Защита разделяемых данных с помощью мьютекса. Класс \texttt{std::mutex}. Методы \texttt{lock}, \texttt{unlock} и \texttt{try\_lock}. В чём недостатки класса \texttt{std::mutex}? Класс \texttt{std::lock\_guard}.  
В чём преимущество \texttt{std::lock\_guard} перед \texttt{std::mutex}? Класс \texttt{std::unique\_lock}. В чём преимущества и недостатки \texttt{std::unique\_lock} перед \texttt{std::lock\_guard}? Взаимоблокировка (deadlock). Решение проблемы взаимоблокировки с помощью стандартной функции \texttt{std::lock}.


\item \textbf{Механизмы синхронизации.}\\
Условные переменные. Класс \texttt{std::condition\_variable} и как им пользоваться? Методы \texttt{wait}, \texttt{notify\_one} и \texttt{notify\_all}. Ложные пробуждения (spurious wake). Запуск асинхронной задачи с помощью функции \texttt{std::async}. Возврат значения из фоновой задачи с помощью объекта класса \texttt{std::future}. Класс задачи -- \texttt{std::packaged\_task}. Зачем могут понадобиться объекты класса \texttt{std::packaged\_task}? Методы класса \texttt{std::packaged\_task}: \texttt{get\_future}, \texttt{operator()}. Передача объекта класса \texttt{std::packaged\_task} в другие функции и потоки. Класс \texttt{std::promise}. Методы класса \texttt{std::promise}: \texttt{get\_future}, \texttt{set\_value} и\\ \texttt{set\_exception}.


\item \textbf{Потокобезопасные стек и очередь с блокировками.}\\
Что такое потокобезопасная структура данных? Являются ли стандартные контейнеры \texttt{STL} потокобезопасными?
Стандартный класс \texttt{std::stack} и его методы \texttt{push}, \texttt{top} и \texttt{pop}. Почему в стандартной библиотеке языка \texttt{C++} стек реализован так, как он реализован? Что такое потокобезопасная структура данных с блокировками? Написание своего потокобезопасного стека с блокировками. Реализация методов \texttt{push} и \texttt{pop} такого стека. Потокобезопасная очередь с блокировками. Реализация методов \texttt{push}, \texttt{try\_pop} и \texttt{wait\_and\_pop} такой очереди.

\item \textbf{Атомарные типы и операции над ними.}\\
Атомарные переменные. В чём отличие атомарных переменных от обычных переменных? Класс \texttt{atomic\_flag} и его методы \texttt{clear} и \texttt{test\_and\_set}. Атомарные типы \texttt{atomic<T>} и методы \texttt{load}, \texttt{store} и \texttt{compare\_exchange}. Упорядочение доступа к памяти. Упорядочения \texttt{memory\_order\_seq\_cst}, \texttt{memory\_order\_acquire}, \\ \texttt{memory\_order\_release} и \texttt{memory\_order\_relaxed}. Реализация спинлока (простейшего мьютекса) на основе атомарной переменной.


\item \textbf{Потокобезопасные стек и очередь без блокировок.}\\
Неблокирующие структуры данных. Структуры данных, свободные от блокировок. Структуры данных, свободные от ожидания. Реализация потокобезопасного стека без блокировок (без устранения утечек памяти). Реализация потокобезопасной очереди без блокировок (без устранения утечек памяти). 

\item \textbf{Управление памятью в структурах данных без блокировок.}\\
Реализация потокобезопасного стека без блокировок (без утечек памяти). Метод подсчёта количества потоков, выполняющих \texttt{pop}. Метод указателей опасности (hazard pointers). В чём преемущества и недостатки каждого из методов. Реализация потокобезопасной очереди без блокировок (без утечек памяти). 

\item \textbf{Пул потоков.}\\
Что такое пул потоков? Реализация пула потоков на языке C++.
Ожидание задачи, переданной пулу потоков.
Предотвращение конкуренции за очередь работ. Занимание работ.

\newpage

\item \textbf{Основы Cmake.}\\
Что такое Cmake и для чего он нужен? Основы работы с CMake. Структура CMake-проекта. Файл CMakeListis.txt. Генерация файлов проекта для данной среды. 
Как скомпилировать проект с помощью CMake? Что такое таргет (target)?\\
Что делают следующие команды CMake:
\begin{itemize}
\item \texttt{cmake\_minimum\_required}
\item \texttt{project}
\item \texttt{set}
\item \texttt{option}
\item \texttt{message}
\item \texttt{add\_executable}
\item \texttt{add\_library} и её опции \texttt{STATIC}, \texttt{SHARED} и \texttt{MODULE}
\item \texttt{target\_link\_libraries} и её опции \texttt{PUBLIC}, \texttt{PRIVATE} и \texttt{INTERFACE}
\item \texttt{target\_compile\_options}
\item \texttt{add\_subdirectory}
\item \texttt{find\_package}
\end{itemize}


\item \textbf{Переменные Cmake.}\\
Переменные Cmake. Как создавать переменные и как их использовать в CMake? Какие типы переменных есть в CMake?
Переменные среды. Кешированные переменные. Чем кешированные переменные отличаются от обычных переменных? Поле \texttt{type} при создании кешированной переменной и какие значения оно может принимать. Изменение кешированных переменных. Задание кешированных переменных внутри CMake-скрипта, в командной строке и путём изменения файла CmakeCache.txt.\\
Переменные:
\begin{itemize}
\item \texttt{CMAKE\_SOURCE\_DIR}
\item \texttt{CMAKE\_BUILD\_DIR}
\item \texttt{CMAKE\_CURRENT\_SOURCE\_DIR}
\item \texttt{CMAKE\_CURRENT\_BUILD\_DIR}
\end{itemize}



\item \textbf{Boost Asio.}\\



\iffalse
\item \textbf{Типы отношений между объектами.}\\
Композиция, ассоциация и наследование. Реализация этих типов отношений на языке \texttt{C++}. UML-диаграмы для представления иерархии классов.


\item \textbf{Паттерны Мост и Стратегия.}\\
Паттерн Мост. Разница между паттернами Мост и Стратегия. Привести примеры использования данных паттернов.


\item \textbf{Паттерны Состояние и Конечный автомат.}\\
Паттерн Состояние. В чём разница между паттернами Состояние и Стратегия. Паттерн Конечный автомат. В чём преимущество при использовании паттерна Конечный автомат для описания изменения состояний объекта по сравнению с использованием перечислений. Привести примеры использования данных паттернов.

\item \textbf{Паттерны Фабричный метод и Абстрактная фабрик.}\\
Паттерн Фабричный метод. Когда используется этот паттерн и зачем он нужен? Фабричный метод как виртуальный конструктор. Паттерн Абстрактная фабрика. Привести примеры использования данных паттернов.


\item \textbf{CMake: основы синтаксиса}\\
Что тако CMake? Зачем нужен CMake и его преимущество перед обычными системами сборки? Файл \texttt{CMakeLists.txt}. Язык CMake. Функция \texttt{message}. Типы CMake как строки. Конкатенация строк. Переменные CMake и функция \texttt{set}. Обычные и кэшированные переменные. Файл \texttt{CMakeCache.txt}. Условный переход \texttt{if} в CMake. \texttt{foreach} в CMake. Функии и макросы в CMake.

\item \textbf{CMake: сборка проектов}\\
Использование CMake для сборки проектов. Функции \texttt{cmake\_minimum\_required}, \texttt{project}. Таргеты в CMake. Функции \texttt{add\_executable} и \texttt{add\_library}. Использование функции, основанных на работе с таргетами, такие как \texttt{target\_include\_directories} и \texttt{target\_compile\_options}. Функция \texttt{target\_link\_libraries} и что она делает. Почему не стоит использовать функции \texttt{include\_directories} и \texttt{link\_libraries}? Функция \texttt{add\_subdirectory}. 

\fi

\end{enumerate}

\end{document}