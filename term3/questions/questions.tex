\documentclass{article}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{amsmath} 
\usepackage{amsfonts}
\usepackage{upgreek}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{geometry}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{ccaption}



\begin{document}
\pagenumbering{gobble}

\section*{Теория:}
\begin{enumerate}


\item \textbf{Наследование.}\\
Наследование в языке \texttt{C++}. Добавление новых полей и методов в наследуемый класс. Вызов конструкторов наследуемого класса. Модификатор доступа \texttt{protected}. Переопределение методов. Чем отличается переопределение от перегрузки. Вызов переопределённого метода класса родителя. Object slicing. Множественное наследование. Ромбовидное наследование.

\item \textbf{Полиморфизм.}\\
Полиморфизм в \texttt{C++}. Указатели на базовый класс, хранящие адрес объекта наследуемого класса.  Виртуальные функции. Таблица виртуальных функций. Ключевые слова \texttt{override} и \texttt{final}. Виртуальный деструктор. Чистые виртуальные функции. Pure virtual call. Абстрактные классы и интерфейсы.

\item \textbf{Move-семантика.}\\
Глубокое копирование и поверхностное копирование. Копирование объекта. Перемещение объекта. Стандартная функция \texttt{std::move}. В чём преимущества перемещения над копированием? Перемещение объекта при возврате из функции. Что такое выражение? lvalue-выражения и rvalue-выражения. Приведите примеры lvalue и rvalue выражений. Зачем нужно разделение выражений на lvalue и rvalue. rvalue-ссылки. В чём разница между lvalue-ссылками и rvalue-ссылками? Конструктор перемещения и оператор присваивания перемещения. Правило пяти.

\item \textbf{Умные указатели.}\\
Недостатки обычных указателей. Умный указатель \texttt{std::unique\_ptr}. Шаблонная функция \texttt{std::make\_unique}. Основы move-семантики. Функция \texttt{std::move}. Перемещение объектов типа \texttt{unique\_ptr}. Умный указатель \texttt{std::shared\_ptr}. Работа с таким указателем. Шаблонная функция \texttt{std::make\_shared}. Базовая реализация \texttt{std::shared\_ptr}. Умный указатель \texttt{std::weak\_ptr}.

\item \textbf{Система типов языка \texttt{C++}.}\\
Система типов языка \texttt{C++}. Встроенные типы, массивы, структуры, объединения, перечисления, классы, указатели, ссылки, функциональные объекты (функции, указатели и ссылки на функции, функторы, лямбда-функции), указатели на члены класса. Вывод типа выражения с помощью \texttt{decltype}. Различие вывода с помощью \texttt{decltype}, \texttt{auto} и вывода шаблонных аргументов. Разложение типов (type decay) и когда он происходит.


\item \textbf{Идеальная передача.}\\
Правила свёртки ссылок. Унивесальные ссылки. Что делает стандартная функция \texttt{std::forward}? Что такое идеальная передача (perfect forwarding) и зачем она нужна? Какие стандартные функции используют идеальную передачу?

\item \textbf{Методы обработки ошибок.}\\
Классификация ошибок. Ошибки времени компиляции, ошибки линковки, ошибки времени выполнения, логические ошибки.
Виды ошибок времени выполнения: внутренние и внешние ошибки. Методы борьбы с ошибками: \texttt{assert}, использование глобальной переменной, коды возврата и исключения. Преемущества и недостатки каждого из этих методов. Какие из этих методов нужно использовать для внутренних ошибок, а какие для внешних.


\item \textbf{Исключения.}\\
Зачем нужны исключения, в чём их преимущество перед другими методами обработки ошибок?
Оператор \texttt{throw}, аргументы каких типов может принимать данный оператор. Что происходит после достижения программы оператора \texttt{throw}. Раскручивание стека. Блок \texttt{try-catch}. Что произойдёт, если выброшенное исключение не будет поймано? Стандартные классы исключений: \texttt{std::exception}, \texttt{std::runtime\_error}, \texttt{std::bad\_alloc}, \texttt{std::bad\_cast}, \texttt{std::logic\_error}. Почему желательно ловить стандартные исключение по ссылке на базовый класс \texttt{std::exception}. Использование \texttt{catch} для ловли всех типов исключений. Использование исключений в кострукторах, деструкторах, перегруженных операторах. Спецификатор \texttt{noexcept}. Гарантии безопасности исключений. Исключения при перемещении объектов. \texttt{move\_if\_noexcept}. Идиома \texttt{copy and swap}.


\item \textbf{Вычисления на этапе компиляции. \texttt{constexpr}} \\
Метапрограммирование с помощью макросов. Метапрограммирование с помощью шаблонов. Вычисление на этапе компиляции с помощью \texttt{constexpr}. Что означает \texttt{constexpr} при объявлении переменной. Что означает \texttt{constexpr} при определении функции. Разница между \texttt{const} и \texttt{constexpr}. \texttt{consteval} и \texttt{constinit}.

\item \textbf{Типы отношений между объектами.}\\
Композиция, ассоциация и наследование. Реализация этих типов отношений на языке \texttt{C++}. UML-диаграмы для представления иерархии классов.


\item \textbf{Паттерны Мост и Стратегия.}\\
Паттерн Мост. Разница между паттернами Мост и Стратегия. Привести примеры использования данных паттернов.


\item \textbf{Паттерны Состояние и Конечный автомат.}\\
Паттерн Состояние. В чём разница между паттернами Состояние и Стратегия. Паттерн Конечный автомат. В чём преимущество при использовании паттерна Конечный автомат для описания изменения состояний объекта по сравнению с использованием перечислений. Привести примеры использования данных паттернов.

\item \textbf{Паттерны Фабричный метод и Абстрактная фабрик.}\\
Паттерн Фабричный метод. Когда используется этот паттерн и зачем он нужен? Фабричный метод как виртуальный конструктор. Паттерн Абстрактная фабрика. Привести примеры использования данных паттернов.


\item \textbf{CMake: основы синтаксиса}\\
Что тако CMake? Зачем нужен CMake и его преимущество перед обычными системами сборки? Файл \texttt{CMakeLists.txt}. Язык CMake. Функция \texttt{message}. Типы CMake как строки. Конкатенация строк. Переменные CMake и функция \texttt{set}. Обычные и кэшированные переменные. Файл \texttt{CMakeCache.txt}. Условный переход \texttt{if} в CMake. \texttt{foreach} в CMake. Функии и макросы в CMake.

\item \textbf{CMake: сборка проектов}\\
Использование CMake для сборки проектов. Функции \texttt{cmake\_minimum\_required}, \texttt{project}. Таргеты в CMake. Функции \texttt{add\_executable} и \texttt{add\_library}. Использование функции, основанных на работе с таргетами, такие как \texttt{target\_include\_directories} и \texttt{target\_compile\_options}. Функция \texttt{target\_link\_libraries} и что она делает. Почему не стоит использовать функции \texttt{include\_directories} и \texttt{link\_libraries}? Функция \texttt{add\_subdirectory}. 


\end{enumerate}

\end{document}