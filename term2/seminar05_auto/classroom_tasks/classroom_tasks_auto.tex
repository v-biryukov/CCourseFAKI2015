\documentclass{article}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{amsmath} 
\usepackage{amsfonts}
\usepackage{upgreek}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{geometry}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{ccaption}
\usepackage{multicol}

\usepackage{listings}
%\setlength{\columnsep}{1.5cm}
%\setlength{\columnseprule}{0.2pt}


\begin{document}
\pagenumbering{gobble}

\lstset{
  language=C++,                % choose the language of the code
  basicstyle=\linespread{1.1}\ttfamily,
  columns=fixed,
  fontadjust=true,
  basewidth=0.5em,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray},
  stringstyle=\ttfamily\color{orange!50!black},
  showstringspaces=false,
  %numbers=false,                   % where to put the line-numbers
  numbersep=5pt,
  numberstyle=\tiny\color{black},
  numberfirstline=true,
  stepnumber=1,                   % the step between two line-numbers.        
  numbersep=10pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
  showstringspaces=false,         % underline spaces within strings
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=true,         % sets if automatic breaks should only happen at whitespace
  xleftmargin=.2in,
  extendedchars=\true,
  keepspaces = true,
}
\lstset{literate=%
   *{0}{{{\color{red!20!violet}0}}}1
    {1}{{{\color{red!20!violet}1}}}1
    {2}{{{\color{red!20!violet}2}}}1
    {3}{{{\color{red!20!violet}3}}}1
    {4}{{{\color{red!20!violet}4}}}1
    {5}{{{\color{red!20!violet}5}}}1
    {6}{{{\color{red!20!violet}6}}}1
    {7}{{{\color{red!20!violet}7}}}1
    {8}{{{\color{red!20!violet}8}}}1
    {9}{{{\color{red!20!violet}9}}}1
}

\title{Семинар \#5: Вывод типов и другие возможности \texttt{C++}. \vspace{-5ex}}\date{}\maketitle

\section*{Часть 1: Ключевое слово \texttt{auto}}
Ключевое слово \texttt{auto} используется для автоматического вывода типа.
\begin{lstlisting}
#include <string>
int main() {
    auto a = 123;   // a будет иметь тип int
    auto b = 4.1;   // b будет иметь тип double
    auto b = 4.1f;  // b будет иметь тип float
    
    auto s1 = "Hello";               // s1 будет иметь тип const char*
    auto s2 = std::string("Hello");  // s2 будет иметь тип std::string
}

\end{lstlisting}


\subsection*{Задачи:}
\begin{itemize}
\item В примере ниже создан вектор строк и напечатано его содержимое. Тип итератора имеет очень длинное название (и название будет ещё больше если контейтер будет хранить не просто строки, а что-нибудь посложнее). Используйте \texttt{auto}, чтобы упростить код.
\begin{lstlisting}
#include <iostream>
#include <vector>
#include <string>

int main() {
    std::vector<std::string> v {"Cat", "Dog", "Elephant"};
    for (std::vector<std::string>::iterator it = v.begin(); it != v.end(); ++it) {
    	std::cout << *it << std::endl;    
    }
}
\end{lstlisting}

\item Протестируйте, можно ли использовать \texttt{auto} вместо возвращаемого типа функции. Напишите функцию, которая принимает на вход вектор строк и возвращает строку, которая является результатом конкатенации всех строк. Вместо возвращаемого типа используйте \texttt{auto}.
\item Протестируйте, можно ли создать функцию, которая будет принимать целое число и, в зависимости от этого числа, возвращать значения разных типов. (Если вместо возвращаемого типа используется \texttt{auto}).

\item Протестируйте, можно ли использовать о указатель с помощью \texttt{auto}. Пусть есть такой участок кода:
\begin{lstlisting}
int a = 123;
auto p = &a;
auto* q = &a;
\end{lstlisting}
Какой тип будет у \texttt{p} и \texttt{q}?
\item Функция вычисления факториала, написанная ниже с использованием \texttt{auto} не работает. 
\begin{lstlisting}
auto factorial(int n) {
    if (n > 0)
        return n * factorial(n - 1);
    return 1;
}
\end{lstlisting}
Почему? Исправьте эту функцию, не убирая \texttt{auto}.

\end{itemize}


\newpage
\section*{Часть 2: Пользовательские литералы}
Существует возможность перегрузить суффикс литерала, используя оператор \texttt{operator"{}"}. Вот как это работает:
\begin{lstlisting}
#include <iostream>
unsigned long long operator"" _k(unsigned long long a) {
    return 1000 * a;
}
void operator"" _print(long double a) {
    std::cout << a << '\n';
}

int main() {
    std::cout << 97_k << std::endl;    // Вызывает _k(97)
    123.5_print;                       // Вызывает _print(123.5)
}
\end{lstlisting}
Есть множество ограничений для такой перегрузки. Во-первых она работает только с литералами и суффикс нельзя применить, например, к переменной. Во-вторых, типы аргументов, которые может принимать \texttt{operator"{}"} сильно ограничены. Ему можно передать такие аргументы:
\begin{itemize}
\item[--] \texttt{T operator"" \_x(unsigned long long)} -- для литералов положительный целых чисел
\item[--] \texttt{T operator"" \_x(long double)} -- для литералов вещественных чисел
\item[--] \texttt{T operator"" \_x(unsigned char)} -- для литералов символов
\item[--] \texttt{T operator"" \_x(const char*, size\_t)} -- для строковых литералов
\end{itemize}
Желательно не злоупотреблять этими операторами и использовать их только в редких случаях, если нужно 

\subsection*{Задача}
\begin{itemize}
\item Напишите перегруженный оператор суффикса \texttt{\_deg}, так чтобы можно было удобнее работать с градусами. Нужно чтобы работал следующий код:
\begin{lstlisting}
auto angle = 1.0 + 45.0_deg; // В angle запишется 1.7854, так 45 градусов = 0.7854 радиан
\end{lstlisting}
\item Напишите перегруженный оператор суффикса \texttt{\_b} для строкового литерала так, чтобы можно было удобнее работать с двоичными числами:
\begin{lstlisting}
auto a = 20 + "11010"_b; // В a запишется 46
\end{lstlisting}
\end{itemize}

\subsection*{Литералы \texttt{std::string}}
Возможность создания пользовательских литералов используется стандартной библиотекой, для создания литералов типа \texttt{std::string}.
В пространстве имён \texttt{std::string\_literals} содержится перегруженный оператор, который позволяет проще создавать такие литералы:
\begin{lstlisting}
std::string operator"" s(const char* p, size_t n) {
    return std::string(p, n);
}
\end{lstlisting}

Вот так их можно создавать в программе:

\begin{lstlisting}
#include <iostream>
#include <string>
using namespace std::string_literals;

int main() {
    auto str = "Cat"s;    // str имеет тип std::string
    std::cout << str + "Dog"s << std::endl; 
}
\end{lstlisting}
\newpage
\section*{Часть 3: Вывод шаблонных аргументов класса}
Начиная со стандарта \texttt{C++17} появилась возможность автоматического вывода шаблонных аргументов классов. Например, в примере ниже больше не нужно указывать шаблонный тип вектора. Компилятор догадается о нём сам.

\begin{lstlisting}
#include <iostream>
#include <vector>

int main() {
    std::vector v {4, 8, 15, 16};
    for (auto it = v.begin(); it != v.end(); ++it) {
    	std::cout << *it << std::endl;    
    }
}
\end{lstlisting}
\subsection*{Задачи:}
\begin{itemize}
\item Создайте вектор, содержащий несколько элементов типа \texttt{double} и напечатайте его.
\item Предположим, что мы создали вектор строк и попытались добавить к концу каждой строки букву \texttt{s} вот так:
\begin{lstlisting}
std::vector v {"Mouse", "Cat", "Dog"};
for (auto it = v.begin(); it != v.end(); ++it) {
    (*it) += "s";
}
\end{lstlisting}
Данный код выдаст ошибку. Почему и как её исправить?
\item Создайте контейнер \texttt{std::set}, содержащий строки \texttt{Mouse}, \texttt{Dog}, \texttt{Cat}. Напечатайте всё содержимое этого контейнера, оно должно напечататься в алфавитном порядке.

\item Создайте вектор, содержащий пары(\texttt{std::pair}) целых чисел и напечатайте его. Используйте вывод шаблонных аргументов класса.
\end{itemize}



\newpage
\section*{Часть 4: Range-based циклы}
Циклы, основанные на диапазоне, предоставляют более простой способ обхода контейнера:
\begin{lstlisting}
#include <iostream>
#include <vector>

int main() {
    std::vector v {6, 1, 7, 4};
    for (int num : v) {
    	std::cout << num << std::endl;    
    }
}
\end{lstlisting}
Для изменения элементов контейнера при обходе нужно использовать ссылки:
\begin{lstlisting}
for (int& num : v) {
    num += 1;    
}
\end{lstlisting}

\subsection*{Задачи:}
\begin{itemize}
\item Проверьте, можно ли использовать ключевое слово \texttt{auto} внутри таких циклов.
\item Пусть у нас есть вектор строк:
\begin{lstlisting}
vector<string> v {"Cat", "Axolotl", "Bear", "Elephant"};
\end{lstlisting}
\begin{itemize}
\item Напишите range-based цикл, который будет печатать все элементы вектора
\item Напишите range-based цикл, который будет добавлять в конец каждой строки символ \texttt{s}.
\item Напишите range-based цикл, который будет обращать каждую строку. Используйте стандартную функцию \texttt{reverse}.
\end{itemize}

\item Проверьте, можно ли использовать range-based циклы если контейнер является:
\begin{multicols}{2}
\begin{itemize}
\item \texttt{std::list}
\item \texttt{std::set}
\item \texttt{std::map}
\item \texttt{std::pair}
\item Обычным массивом
\item \texttt{std::string}
\item Строкой в стиле \texttt{C}
\end{itemize}
\end{multicols}

\item Для печати массива целых чисел была написана следующая функция:
\begin{lstlisting}
void print(int array[]) {
    for (int num : array) {
        std::cout << num << std::endl;
    }
}
\end{lstlisting}
Оказывается, что она не работает. В чём заключается ошибка?
\end{itemize}


\newpage
\section*{Часть 5: Direct и copy-list-initialization}
По сравнению с \texttt{C} и с ранними стандартами \texttt{C++} добавились новые способы инициализации объектов.
Пусть есть простая структура или класс \texttt{Book}:
\begin{multicols}{2}
\begin{lstlisting}
struct Book {
    string title;
    int pages;
    float price;
};
\end{lstlisting}
\vfill\null
\columnbreak
\begin{lstlisting}
class Book {
private:
    string title;
    int pages;
    float price;
public:
    Book(string a, int b, float c) 
     : title(a), pages(b), price(c) {};
};
\end{lstlisting}
\end{multicols}

\subsection*{Direct-list-initialization}
Структуры инициалируются поэлементно, а для объектов класса вызовется конструктор. Работает для всех(?) типов: базов типов, структур, объектов с конструкторами и даже для динамического выделения памяти с \texttt{new}. Поддерживает вложенность.
\begin{lstlisting}
Book a {"Doctor Zhivago", 592, 800};
 \end{lstlisting}   
    
\subsection*{Copy-list-initialization, когда применяется:}
\begin{itemize}
\item По идее должен создасться временный объект, а потом вызваться конструктор копирования. Но на практике временный объект оптимизируется и эта инициализация аналогична предыдущей.
\begin{lstlisting}
Book a = {"War and Peace", 1225, 800};
\end{lstlisting}

\item Правая часть оператора присваивания. Сначала создастся временный объект, а потом вызовется оператор присваивания.
\begin{lstlisting}
a = {"War and Peace", 1225, 800};
\end{lstlisting}

\item Аргумент функции. Сначала создастся временный объект, а потом вызывается конструктор копирования, чтобы скопировать объект внутрь функции. На практике же это всё оптимизируется (смотрите Copy elision)
\begin{lstlisting}
void print(Book b) {
    cout << a.title << endl;
}
...
print({"War and Peace", 1225, 800});
\end{lstlisting}

\item Возвращаемое значение функции. Сначала создастся временный объект, а потом вызывается конструктор копирования, чтобы скопировать объект из функции. На практике же это всё оптимизируется (смотрите Return value optimization).
\begin{lstlisting}
Book get_war_and_peace() {
    return {"War and Peace", 1225, 800};
}
\end{lstlisting}
\end{itemize}
Более подробный пример и задания -- в файле \texttt{0copy\_list\_initialization.cpp}.
\subsection*{Copy-elision и return value optimization}
Это полезные оптимизации, которые отбрасывают ненужные копирования при передачи объекта в функцию или из функции. 
Смотрите примеры в файлах \texttt{1copy\_elision.cpp}, \texttt{2copy\_elision.cpp}, \texttt{3copy\_elision.cpp}.

\newpage
\section*{Часть 6: \texttt{std::initializer\_list}}
Применим полученные знания по инициализации для класса \texttt{std::vector}. Известно, что если написать так:
\begin{lstlisting}
std::vector<int> v {1, 2, 3, 4, 5};
\end{lstlisting}
то создастся вектор размера 5, с соответствующими элементами. Причём количество элементов в инициализации может быть произвольным. Это означает, что у вектора должен был вызваться конструктор, который может принимать произвольное количество аргументов.

Такой конструктор у вектора на самом деле есть, но он принимает на вход не произвольное число элементов, а один специальный объект, который называется \texttt{std::initializer\_list}. Это шаблонный контейнер константных элементов. Он прямо встроен в язык (для него не нужно подключать библиотеки). Его особеность в том, что он автоматически создаётся в некоторых ситуациях при инициализации с помощью фигурных скобочек.

Вот пример функции, которая тоже принимает на вход такой контейнер:
\begin{lstlisting}
#include <iostream>
void print(std::initializer_list<int> elems) {
    for (int el : elems) {
        std::cout << el << " ";
    }
    std::cout << std::endl;
}
int main() {
    print({1, 2, 3});
    print({9, 8, 7, 6, 5});
}
\end{lstlisting}
\texttt{std::initializer\_list} следует отличать от инициализации фигурными скобками (это лишь частный случай такой инициализации). Например, в пример предыдущей части он ни разу не использовался. 


\subsection*{Задачи:}
\begin{itemize}
\item Что будут содержать следующие векторы и почему?
\begin{lstlisting}
std::vector<int> v1 {3, 1};
std::vector<int> v2 = {3, 1};
std::vector<int> v3(3, 1);
\end{lstlisting}

\item Что если создать переменную \texttt{a} следующим образом? Какой тип будет у \texttt{a}?
\begin{lstlisting}
auto a = {1, 2, 3, 4};
\end{lstlisting}
Что если в фигурных скобках будут объекты разных типов?

\item Будет ли работать такой код?
\begin{lstlisting}
for (auto x : {4, 8, 15, 16}) {
    cout << x << " ";
}
\end{lstlisting}

\item Сделайте функцию \texttt{print} из примера выше шаблонной так, чтобы работали следующие вызовы:
\begin{lstlisting}
print({1, 2, 3});
print({"Cat", "Dog", "Mouse"});
\end{lstlisting}

\item Создайте класс \texttt{SumInfo} у которого будет конструктор и метод \texttt{add} принимающие \texttt{std::initializer\_list}
\begin{lstlisting}
SumInfo a {1, 2, 3, 9};
cout << a.getCount() << " " << a.getSum() << endl;  // Напечатает 4 15
a.add({7, 3, 1});
cout << a.getCount() << " " << a.getSum() << endl;  // Напечатает 7 26
\end{lstlisting}


\end{itemize}




\newpage
\section*{Часть 7: Structure binding (структурное связывание)}
В стандарте \texttt{C++17} был добавлен новый вид объявления и инициализации нескольких переменных. В коде ниже мы объявляем переменные \texttt{a} и \texttt{b} одной строкой с помощью структурного связывания.
\begin{lstlisting}
#include <iostream>
#include <utility>

int main() {
    std::pair p {5, 1};
    auto [a, b] = p;
    
    std::cout << a << " " << b << std::endl;
}
\end{lstlisting}
Структурное связывание работает только в том случае, если размер контейнера справа известен на стадии компиляции. Например, пары, кортежи(\texttt{std::tuple}), статические массивы, \texttt{std::array}, простые структуры.

\subsection*{Задачи:}
\begin{itemize}
\item Пусть у нас есть пара:
\begin{lstlisting}
std::pair p {std::string{"Moscow"}, 1147};
\end{lstlisting}
\begin{itemize}
\item Создайте две переменные \texttt{name} и \texttt{age} и присвойте их соответствующим элементам пары.
\item Создайте две ссылки \texttt{name} и \texttt{age} и инициализируйте их соответствующими элементами пары. Убедитесь, что при изменении переменной \texttt{name} меняется и пара \texttt{p}.
\end{itemize}

\item Метод \texttt{insert} контейнера \texttt{std::set}  пытается вставить элемент в множество. Если же такой элемент в множестве уже существует, то он ничего с множеством не делает. Но этот метод возвращает пару из итератора на соответствующий элемент и переменной типа \texttt{bool}, которая устанавливается в \texttt{true} если новый элемент был добавлен и в \texttt{false}, если такой элемент уже существовал. Вот пример программы, которая пытается вставить элемент в множество и печатает соответствующее сообщение. В любом случае программа печатает все элементы, меньшие вставляемого.

\begin{lstlisting}
#include <iostream>
#include <utility>
#include <set>
using std::cout;
using std::endl;
int main() {
    std::set<int> s {1, 2, 4, 5, 9};
    
    std::pair<std::set<int>::iterator, bool> result = s.insert(5);
    if (result.second == true) {
        cout << "Element added successfully" << endl;
    }
    else {
        cout << "Element already existed" << endl;
    }
    
    for (std::set<int>::iterator it = s.begin(); it != result.first; ++it) {
        cout << *it << " ";
    }
}
\end{lstlisting}
Упростите эту программу, используя ключевое слово \texttt{auto} и структурное связывание.
\end{itemize}
\newpage
Структурное связывание можно использовать и в цикле.
\begin{lstlisting}
#include <iostream>
#include <utility>
#include <vector>

int main() {
    std::vector<std::pair<std::string, int>> v {{"Moscow", 1147}, {"Berlin", 1237}, 
                                                {"Rome", -753},  {"Bogota ", 1538}};
    for (auto [city, year] : v) {
        std::cout << city << " " << year << std::endl;
    }
}
\end{lstlisting}

\subsection*{Задачи:}
\begin{itemize}
\item В файле \texttt{books.cpp} лежит заготовка кода. В ней содержится инициализированный массив из структур. Сделайте следующее:
\begin{itemize}
\item Напечатайте массив \texttt{books}, используя range-based цикл. Нужно напечатать все поля через запятую.
\item Напечатайте массив \texttt{books}, используя range-based цикл со структурным связыванием.
\item Увеличьте поле \texttt{price} всех книг на одну величину, используя range-based цикл.
\item Увеличьте поле \texttt{price} всех книг на одну величину, используя range-based цикл со структурным связыванием.
\end{itemize}
\item Ниже есть пример программы -- решение задачи с предыдущего семинара. Она считывает слова и печатает количества всех введённых до этого слов.
\begin{lstlisting}
#include <iostream>
#include <map>
#include <utility>
#include <string>
using std::cout;
using std::endl;

int main() {
    std::map<std::string, int> word_count;
    
    while (true) {
        std::string word;
        std::cin >> word;
        std::pair<std::string, int> wc {word, 1};
        std::pair<std::map<std::string, int>::iterator, bool> p = word_count.insert(wc);
        if (p.second == false) {
            word_count[word] += 1;
        }
        
        cout << "Dictionary:" << endl;
        for (std::map<std::string, int>::iterator it = word_count.begin(); 
                                it != word_count.end(); ++it) {
            std::cout << (*it).first << ": " << (*it).second << endl;
        }
        cout << endl;
    } 
}
\end{lstlisting}
Упростите код этой программы, используя \texttt{auto} и структурное связывание.
\end{itemize}

\newpage
\section*{Часть 8: Введение в лямбда-функции}
Лямбда-функции -- это анонимные функции, с которыми можно работать как с обычными переменными. Тип лямбда функции разный для каждой лямбда функции и мы его не можем узнать (это \textbf{не} указатели на функцию). Но это не проблема, переменную лямбда-функцию всё равно можно создать, используя ключевое слово \texttt{auto}.
\begin{lstlisting}
#include <iostream>
int main() {
    auto f = [](int x) {std::cout << x << std::endl;};
    f(123);
}
\end{lstlisting}

Самый частый случай применения лямбда-функций -- это их передача аргументом в функцию. В частности, многие стандартные алгоритмы STL могут принимать на вход лямбда-функции. Например, функция \texttt{std::sort} третьим аргументом может принять лямбда-функцию-компаратор. А функция \texttt{std::for\_each} вызывает лямбда-функцию поочерёдно от каждого элемента.

\begin{lstlisting}
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector v {18, 51, 2, 25, 14, 97, 73};
    std::sort(v.begin(), v.end(), [](int a, int b) {return a > b;});
    std::for_each(v.begin(), v.end(), [](int a) {std::cout << a << " ";});
}
\end{lstlisting}

\begin{itemize}
\item Отсортируйте массив чисел по возрастанию последней цифры числа, используя лямбда функции.
\item Предположим, что у нас есть вектор строк:
\begin{lstlisting}
std::vector {"Elephant"s, "Cat"s, "Zebra"s, "Dog"s, "Hippopotamus"s, "Mouse"s, "Tiger"s};
\end{lstlisting}
\begin{itemize}
\item Отсортируйте его лексиграфически по возрастанию
\item Отсортируйте его лексиграфически по убыванию
\item Отсортируйте его по длине каждой строки по возрастанию
\end{itemize}
\end{itemize}

\begin{itemize}
\item Используйте функцию \texttt{std::transform} лямбда функцию и \texttt{std::back\_inserter}, чтобы по вектору \texttt{v} создать новый вектор, содержащий последние цифры чисел.
\item В файле \texttt{movies.cpp} содержится заготовка кода. Отсортируйте массив \texttt{movies}, используя лямбда-функции:
\begin{itemize}
\item по рейтингу
\item по названию
\item по дате
\end{itemize}
\item Измените массив \texttt{movies}, с помощью \texttt{std::transform} и лямбда функций, так, чтобы
\begin{itemize}
\item рейтинг каждого фильма уменьшился на 1
\item название каждого фильма было переведено в верхний регистр
\end{itemize}

\item Создайте новый вектор, который будет содержать только фильмы с рейтингом \texttt{8} и выше. Используйте функцию \texttt{copy\_if}, лямбда выражение и \texttt{std::back\_inserter}.

\item Удалите все фильмы из массива, который вышли в 90-е годы. Используйте функцию \texttt{remove\_if} и \texttt{erase} и лямбда выражение.
\end{itemize}
\end{document}