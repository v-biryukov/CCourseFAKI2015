\documentclass{article}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{amsmath} 
\usepackage{amsfonts}
\usepackage{upgreek}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{geometry}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{ccaption}
\usepackage{multicol}

\usepackage{listings}
%\setlength{\columnsep}{1.5cm}
%\setlength{\columnseprule}{0.2pt}


\begin{document}
\pagenumbering{gobble}

\lstset{
  language=C++,                % choose the language of the code
  basicstyle=\linespread{1.1}\ttfamily,
  columns=fixed,
  fontadjust=true,
  basewidth=0.5em,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray},
  stringstyle=\ttfamily\color{orange!50!black},
  showstringspaces=false,
  %numbers=false,                   % where to put the line-numbers
  numbersep=5pt,
  numberstyle=\tiny\color{black},
  numberfirstline=true,
  stepnumber=1,                   % the step between two line-numbers.        
  numbersep=10pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
  showstringspaces=false,         % underline spaces within strings
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=true,         % sets if automatic breaks should only happen at whitespace
  xleftmargin=.2in,
  extendedchars=\true,
  keepspaces = true,
}
\lstset{literate=%
   *{0}{{{\color{red!20!violet}0}}}1
    {1}{{{\color{red!20!violet}1}}}1
    {2}{{{\color{red!20!violet}2}}}1
    {3}{{{\color{red!20!violet}3}}}1
    {4}{{{\color{red!20!violet}4}}}1
    {5}{{{\color{red!20!violet}5}}}1
    {6}{{{\color{red!20!violet}6}}}1
    {7}{{{\color{red!20!violet}7}}}1
    {8}{{{\color{red!20!violet}8}}}1
    {9}{{{\color{red!20!violet}9}}}1
}

\title{Семинар \#4: Контейнеры STL. \vspace{-5ex}}\date{}\maketitle


\section*{Часть 1: Контейнеры}
Стандартная библиотека шаблонов (STL = Standard Template Library) включает в себя множество разных шаблонных контейнеров и алгоритмов для работы с ними.

\begin{center}
\begin{tabular}{ l | l }
 контейнер & описание и основные свойства \\ \hline


 \texttt{std::vector} & Динамический массив \\
                      & Все элементы лежат вплотную друг к другу, как в массиве \\
                      & Есть доступ по индексу за $O(1)$ \\ \\ \hline
 \texttt{std::list} & Двусвязный список \\
                    & Вставка/удаление элементов за $O(1)$ если есть итератор на элемент \\ \\ \hline
 \texttt{std::forward\_list} & Односвязный список \\
                     & Вставка/удаление элементов за $O(1)$ если есть итератор на предыдущий элемент\\ \\ \hline
 \texttt{std::set} & Реализация множества на основе сбалансированного дерева поиска \\
				   & Хранит элементы без дубликатов, в отсортированном виде\\
				   & Тип элементов должен реализовать \texttt{operator<} (или предоставить компаратор)\\
                   & Поиск/вставка/удаление элементов за $O(\log(N))$ \\ \\ \hline
 \texttt{std::map} & Реализация словаря на основе сбалансированного дерева поиска \\
				   & Хранит пары ключ-значения без дубликатов ключей, в отсортированном виде\\
				   & Тип ключей должен реализовать \texttt{operator<}  (или предоставить компаратор)\\
                   & Поиск/вставка/удаление элементов за $O(\log(N))$ \\ \\ \hline
 \texttt{std::unordered\_set} & Реализация множества на основе хеш-таблицы \\
				   & Хранит элементы без дубликатов, в произвольном порядке\\
                   & Поиск/вставка/удаление элементов за $O(1)$ в среднем \\ \\ \hline
 \texttt{std::unordered\_map} & Реализация словаря на основе хеш-таблицы \\
				   & Хранит пары ключ-значения без дубликатов ключей,в произвольном порядке\\
                   & Поиск/вставка/удаление элементов за $O(1)$ в среднем  \\ \\ \hline
 \texttt{std::multiset} & То же самое, что \texttt{std::set}, но может хранить дублированные значения \\ \\ \hline
 \texttt{std::deque} & Двухсторонняя очередь \\
				     & Добавление/удаление в начало и конец за $O(1)$\\ \\  \hline
 \texttt{std::stack} & Стек \\
 \texttt{std::queue} & Очередь \\
 \texttt{std::priority\_queue} & Очередь с приоритетом \\ \\ \hline
 
 \texttt{std::pair} &  Пара элементов, могут быть объектами разных типов \\
                      & Элементы пары хранятся в публичных полях \texttt{first} и \texttt{second} \\ \\ \hline
 \texttt{std::tuple} &  Фиксированное количество элементов, могут быть объектами разных типов \\ \\ \hline
 \texttt{std::array} &  Массив фиксированного размера, все элементы имеют один тип \\ \\ \hline
\end{tabular}
\end{center}




\newpage
\section*{Часть 2: \texttt{std::set}}
\texttt{std::set} -- это реализация множества с помощью бинарного дерева поиска. Не хранит дупликатов. При попытке добавить в множество тот элемент, который в нём уже есть, ничего не произойдёт. Также все элементы в множестве всегда хранятся в отсортированном виде (так как это бинарное дерево поиска). Для типа элементов множество должен быть реализован \texttt{operator<}. В \texttt{std::set} нельзя менять элементы, так как это бинарное дерево поиска, но можно удалить элемент, а потом вставить новый.\\

Основные методы для работы с множеством:
\begin{center}
\begin{tabular}{ l | l }
 метод & описание \\ \hline
 \texttt{insert}  & Вставляет элемент в множество\\ \\\hline
 \texttt{erase}   & Удаляет элемент. Можно удалять по значению элемента или по итератору.  \\ 
                  & Также можно сразу удалить диапазон значений, если передать 2 указателя \\\\ \hline
 \texttt{find(x)} & Принимает на вход значение \texttt{x} и ищет такой элемент в множестве. Возвращает итератор на \\
                  &  этот элемент или итератор \texttt{end()}, если такого элемента нет\\ \\ \hline
 \texttt{count(x)}  & Принимает значение и находит, сколько элементов равны этому значению (т.е. 0 или 1) \\ \\\hline
 \texttt{lower\_bound(x)}  & Возвращает итератор на первый элемент, который больше или равен \texttt{x} \\
 \texttt{upper\_bound(x)}  & Возвращает итератор на первый элемент, который больше \texttt{x} \\
\end{tabular}
\end{center}



\begin{itemize}

\item На вход подаётся $n$ чисел. Напечатайте эти числа удалив все дупликаты.
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{10} & \texttt{1 2 7 8}  \\ 
 \texttt{8 2 1 2 2 1 8 7 1 2} &  \\
\end{tabular}
\end{center}


\item На вход подаётся $n$ чисел и некоторое число \texttt{x}. Найдите пару элементов массива, такую что их сумма равна \texttt{x}. Напечатайте индексы этих элементов. При наличии нескольких таких пар, напечатайте любую. Решение должно работать за $O(n \log(n))$ или быстрее.
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{8} & \texttt{2 4}  \\ 
 \texttt{8 2 5 4 9 1 7 4} &  \\
 \texttt{14} &  \\
\end{tabular}
\end{center}
\end{itemize}


\subsection*{\texttt{std::multiset}}
То же самое, что и \texttt{std::set}, но может хранить дупликаты. Одна из неочевидных особенностей \texttt{multiset} это то, что при удалении элемента по значению \texttt{erase(x)}, удалятся все элементы, равные \texttt{x}. Для удаления одного элемента нужно передать в \texttt{erase} итератор на элемент.
\begin{itemize}
\item Считайте $n$ чисел и отсортируйте их с помощью вставки в \texttt{multiset}. Распечатайте отсортированные числа.
\item На прямой лежит верёвка длиной $n$ метров. Затем её начинают последовательно разрезать. Все места разрезов -- целые числа. Найти длину самого длинного куска после каждого разреза.
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{20 8} & \texttt{12 10 8 7 6 5 5 4}  \\ 
 \texttt{8 10 15 1 7 4 11 18} &  \\
\end{tabular}
\end{center}
\end{itemize}

\newpage
\section*{Часть 3: \texttt{std::map}}
\texttt{std::map} -- это реализация словаря с помощью бинарного дерева поиска. Не хранит ключе - дупликатов. При попытке добавить в этот словарь элемента с ключом, который в нём уже есть, ничего не произойдёт. Также все элементы в этом словаре всегда хранятся в отсортированном по ключам виде (так как это бинарное дерево поиска). Для типа ключей должен быть реализован \texttt{operator<}. В \texttt{std::map} можно менять значения, но нельзя менять ключи, так как это бинарное дерево поиска. Но можно удалить элемент каким-то ключом, а потом вставить новый с другим ключом.\\

Основные методы для работы с множеством:
\begin{center}
\begin{tabular}{ l | l }
 метод & описание \\ \hline
 \texttt{insert(k, v)}  & Вставляет элемент с ключом \texttt{k} и значением \texttt{v}\\
                        & Если такой элемент уже есть, то ничего не делает \\ \\\hline
 \texttt{operator[]}    &  Вставляет элемент с ключом \texttt{k} и значением \texttt{v}\\
 \texttt{m[k] = v}      & Если такой элемент уже есть, то меняет его значение \\ \\\hline
 \texttt{erase(k)}      & Удаляет элемент. Можно удалять по значению элемента или по итератору.  \\ 
                        & Также можно сразу удалить диапазон значений, если передать 2 указателя \\\\ \hline
 \texttt{find(x)}       & Принимает на вход значение \texttt{x} и ищет элемент с таким ключом. Возвращает итератор на \\
                        &  этот элемент или итератор \texttt{end()}, если такого ключа нет\\ \\ \hline
 \texttt{count(x)}      & Принимает значение и находит, сколько ключей равны этому значению (т.е. 0 или 1) \\ \\\hline
 \texttt{lower\_bound(x)}  & Возвращает итератор на первый элемент, который больше или равен \texttt{x} \\
 \texttt{upper\_bound(x)}  & Возвращает итератор на первый элемент, который больше \texttt{x} \\
\end{tabular}
\end{center}

Пример программы, которая создаёт словарь из пар <название города, его население>. Строка выступает в качестве ключа, а целое число -- в качестве значения.
\begin{lstlisting}
#include <iostream>
#include <string>
#include <map>
using std::cout, std::endl;

int main () 
{
    std::map<string, int> m = {{"London", 8900000}, {"Moscow", 12500000}, {"Milan", 4300000}};

    std::string cityName;
    while (true) 
    {
        std::cin >> cityName;
        if (cityName == "q" || cityName == "quit")
            break;
            
        std::map<std::string, int>::iterator it = m.find(cityName);
        if (it == m.end())
            cout << "No such city" << endl;
        else
            cout << "City " << cityName << " population = " << it->second << endl;
    }
}
\end{lstlisting}


\newpage
\begin{itemize}
\item Напишите программу, которая будет в бесконечном цикле считывать слова и после каждого считывания печатать все уникальные слова, считанные ранее и количество таких слов. Например, если пользователь ввёл слово \texttt{Cat} три раза, слово \texttt{Dog} 1 раз и слово \texttt{Elephant} 2 раза. То после очередного считывания программа должна напечатать:
\begin{verbatim}
Dictionary:
Cat: 3
Dog: 1
Elephant: 2
\end{verbatim}
\item Считайте все слова из файла и напечатайте все уникальные слова и то, как часто они встречались в файле. Сохраните результат в новом файле. Для работы с файлами можно использовать функции \texttt{C}.
\begin{center}
\begin{tabular}{ l | l }
 входной файл & выходной файл \\ \hline
 \texttt{I'm having Spam, Spam, Spam, Spam, Spam, Spam,} & \texttt{I'm 1}  \\
 \texttt{Spam, baked beans, Spam, Spam, Spam and Spam.}  &  \texttt{Spam 1}  \\
                                                         &  \texttt{Spam, 9}  \\ 
                                                         &  \texttt{Spam. 1}  \\ 
                                                         &  \texttt{and 1}  \\ 
                                                         &  \texttt{beans, 1}  \\ 
                                                         &  \texttt{having 1}  \\                                                      
\end{tabular}
\end{center}
\end{itemize}

\end{document}