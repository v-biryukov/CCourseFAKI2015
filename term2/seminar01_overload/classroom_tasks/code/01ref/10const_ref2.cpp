/* 
    Константные ссылки нужны прежде всего, чтобы передавать большие объекты в функции, 
    внутри которых они не должны меняться.


    Рассмотрим структуру Book, чей размер более 100 байт
    
    
    1)  При передаче такой структуры в функцию по значению, как это происходит в функции printBookV,
        вся структура будет копироваться внутрь функции и это очень медленно. Так делать не стоит.


    2)  При передаче такой структуры в функцию по обычной ссылке, как это происходит в функции printBookR, 
        структура не копируется. На самом деле, под капотом внутрь функции копируется адрес структуры.
        Адрес намного меньше самой структуры, поэтому это копирование работает намного быстрее.

        Но возникает проблема с тем, что структура внутри такой функции может поменяться.
        В реальной ситуации, если функций много и они большие, уследить за тем меняется ли аргументы внутри
        функций становится проблематично.


    3)  При передаче такой структуры в функцию по константной ссылке, как это происходит в функции printBookCR,
        структура не копируется. Плюс, мы можем быть уверены, что внутри функции наша структура не поменяется 
        и это сильно упрощает понимание программы.
*/

#include <iostream>
#include <cmath>
using std::cout, std::endl;

struct Book
{
    char title[100];
    int pages;
    float price;
};


void printBookV(Book b)
{
    cout << b.title << ", pages = " << b.pages << ", price = " << b.price << endl;
}


void printBookR(Book& b)
{
    cout << b.title << ", pages = " << b.pages << ", price = " << b.price << endl;
}


void printBookCR(const Book& b)
{
    cout << b.title << ", pages = " << b.pages << ", price = " << b.price << endl;
}


int main() 
{
    Book b = {"War and Peace", 1200, 900};

    printBookV(b);
    printBookR(b);
    printBookCR(b);
}


