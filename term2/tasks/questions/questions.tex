\documentclass{article}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{amsmath} 
\usepackage{mathtext}
\usepackage{amsfonts}
\usepackage{upgreek}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{geometry}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{ccaption}



\begin{document}
\pagenumbering{gobble}

\section*{Теория:}
\begin{enumerate}

\item  \textbf{O(n) нотация}\\
Что такое $O(n)$, $\Omega(n)$ и $\Theta(n)$ нотации, математическое определение и смысл.
Знать(или уметь выводить) сложности всех пройденных алгоритмов: алгоритм бинарного поиска в отсортированном массиве, алгоритмы сортировки (пузырьком, вставками, выбором, быстрая, сортировка слиянием, подсчётом, цифровая). Знать или уметь выводить сложности операций с пройденными структурами данных: поиск массива по индексу в массиве и списке, вставка в массив(статический и динамический) и список; удаление из массива и списка; поиск по массиву и списку.

\item \textbf{Структуры данных. Статический и динамический массив. Связный список}\\
Что такое структура данных.
Статический массив. Объявление, инициализация и использование статического массива в языках C и C++. Динамический массив. Объявление, инициализация и использование динамического массива в языках C и C++. Операции доступа к элементу, добавления(в начало, середину и конец) и удаления из массива и их сложности. Связный список. Как реализуются функции нахождения длины списка, вставки элемента в начало/конец, удаления элемента из начала/конца, поиска в списке, обращения списка. Алгоритмические сложности операций со списком. Двусвязный список. Использование динамического массива в языке C++, стандартный контейнер vector. Использование связного списка в языке C++, стандартный контейнер list. 

\item \textbf{Структуры данных. Графы и деревья.}\\
Что такое структура данных.
Определения графа. Связный граф, взвешенный граф, простой граф, ациклический граф, дерево. Представления графа с помощью списка смежных вершин и матрицы смежности. Обход в глубину и ширину. Алгоритм Дейкстры. Использование очереди с приоритетом в алгоритме Дейкстры. Деревья и их реализация на языке C. Бинарные деревья поиска и их реализация на языке C. Проход по дереву. Операции поиска, добавления и удаления элемента в дерево. Их сложность и реализация на языке C.

\item \textbf{Структуры данных. Хэш-таблица.}\\
Что такое хэш функция. Свойства хорошей хэш-функции. Что такое хэш-таблица. Колизии, метод цепочек и открытая адресация. Операцию добавления элемента в хэш-таблицу, операцию поиска и операцию удаления элемента в хэш-таблице и их сложность. \textbf{*}Примеры различных хэш-функций. \textbf{*}Хэш-функции основанные на делении. \textbf{*}Хэш-функция Пирсона.

\item  \textbf{Абстрактные типы данных. Стек, очередь и очередь с приоритетом.}\\
Что такое абстрактный тип данных.
Различие между структурой данных и абстрактным типом данных. Стек. Операции push и pop. Реализация стека на основе массива. Динамическое выделение памяти для стека. Стратегии перевыделения памяти(аддитивная и мультипликативная).  Очередь. Реализация стека и очереди на основе связного списка. Алгоритмические сложности операций со стеком и очередью. Очередь с приоритетом. \textbf{*}Двоичная куча. \textbf{*}Реализация очереди с приоритетом с помощью двоичной кучи.

\item  \textbf{Абстрактные типы данных. Множество и словарь.}\\
Множество. Реализация множества с помощью дерева и с помощью хэш-таблицы. Операции поиска элемента в множестве, добавления и удаления элемента в множестве. Использование множеств в языке C++(контейнеры библиотеки STL: set, multiset, unordered\_set и unordered\_multiset). \\
Словарь (или ассоциативный массив). Пара Ключ-Значение. Реализация словаря с помощью дерева и с помощью хэш-таблицы. Операции поиска элемента в множестве, добавления и удаления элемента в словаре. Использование словарей в языке C++(контейнеры библиотеки STL: map, multimap, unordered\_map и unordered\_multimap).

\item \textbf{Cортировка}\\
Знать сортировки пузырьком, вставками, выбором, быструю сортировку, сортировку слиянием, подсчётом и сортировка выбором. Алгоритмические сложности всех этих алгоритмов. Уметь писать сортировку выбором, быструю сортировку и сортировку подсчётом. Парадигма разделяй и властвуй. Логарифмическая сложность. Алгоритм бинарного поиска в отсортированном массиве, сортировка слиянием, быстрая сортировка.

\item \textbf{Память}\\
Что такое переменная. Адреса переменных. Указатели. Определение адреса переменной. Разыменование. Основные типы данных и их размеры: \texttt{int, float double, char, void*, int*, char*}. Адресная арифметика. Динамическое выделение и освобождение памяти в куче: malloc(), free() и realloc(). Утечки памяти. Указатель \texttt{void*}.

\item \textbf{Передача аргументов в функцию в C и C++}\\
Все типы передачи аргументов в функцию. Передача по ссылке и передача по значению. Передача через адрес переменной. Передача через указатель на константу. Ссылки C++. Передача по ссылке(reference C++). Передача через константную ссылку(C++). Передача массивов, строк и двумерных массивов в функцию. Передача структур в функцию. Возвращение аргумента. Возвращение нескольких аргументов из функции. Возвращение массива из функции. Ключевое слово void. 

\item \textbf{Сегменты памяти}\\
Что такое сегменты памяти. Сегмент памяти стек вызовов(или просто стек). Выделение памяти в стеке. Переполнение стека. Сегмент памяти куча(heap). Динамическое выделение и освобождение памяти в куче: malloc(), free() и realloc(). Динамическое выделение двумерного массива. Преимущества и недостатки кучи перед стеком. Сегмент памяти text. Ошибка Segmentation Fault.

\item \textbf{Этапы компиляции. Сборка проекта.}\\
Что такое файл исходного кода и исполняемый файл. Этап компиляции: препроцессинг, компиляция и линковка. Директивы препроцессора \#include и \#define. Компиляция программы с помощью gcc. Опции gcc: -E, -c. Header-файлы. Раздельная компиляция, её преемущество. Make-файлы. Cmake.

\item \textbf{Побитовые операции. Представление базовых типов в памяти компьютера.}\\
Побитовые операции: побитовые И, ИЛИ, НЕ, исключающее ИЛИ. Побитовые сдвиги влево и вправо. Умножение числа на степень двойки  с помощью побитовых сдвигов. Представление беззнакового целого числа(unsigned int) в памяти компьютера. Представление знакового целого числа(int) в памяти компьютера, дополнительный код. Представление вещественного числа(float) в памяти компьютера. IEEE 754. Порядок байтов, Little и Big Endian.

\item \textbf{С++ features}\\
Ссылки(reference), передача аргументов в функцию с помощью ссылок и с помощью константных ссылок. Ввод и вывод в C++, cin и cout. Перегрузка функций в C++. Значения аргументов функций по умолчанию в C++. Операторы new/delete. Их преимущества по сравнению с malloc/free. Класс string. Строки C++(string) и строки в стили C (char*), их различия.\\
Дополнительные фичи C++11. Ключевое слово auto. Обобщённая инициализация(с помощью \{\}). Range-based for loop.

\item \textbf{Объектно-ориентированное программирование (ООП). Основы.}\\
Основные принципы ООП: инкапсуляция, наследование и полиморфизм. Элементы ООП в языке C. Классы C++. Поля и методы класса. Модификаторы доступа public и private. Различие между ключевыми словами struct и class. Преимущества закрытых(private) полей и методов. Конструкторы. Перегрузка конструкторов. Конструктор по умолчанию. Список инициализации конструктора. Деструкторы. RAII. Скрытый указатель this. Ключевое слово static. Статические поля класса. Ключевое слово friend. Дружественные функции и классы. Перегрузка операторов в C++. Преимущество перегрузки операторов. Перегрузка operator+, operator*, operator>, operator<<.

\item \textbf{Объектно-ориентированное программирование (ООП). Наследование.}\\
Зачем нужно наследование? Наследование в C++. Модификатор доступа protected. Добавление новых полей и методов в классе наследнике. Перегрузка функций в классе наследнике. Работа с указателем базового класса на экземпляр класса-наследника. Виртуальные функции и ключевое слово virtual. Таблица виртуальных методов. Абстрактные виртуальные функции. Абстрактные виртуальные классы. Интерфейсы. Виртуальный деструктор.

\item \textbf{Шаблоны.}\\
Шаблонные функции. Шаблоны классов. Использование шаблонов функций и классов. Переменная, как шаблонный параметр. Библиотека STL. Шаблонный класс pair. Шаблонные контейнеры vector, set, list, map. Итераторы STL. Проход по контейнеру с помощью итераторов. Стандартные функции find() и sort().

\end{enumerate}



\newpage


\section*{Материалы для подготовки:}
\subsection*{1-й семестр:}
\begin{enumerate}
\item Кормен, Лейзерсон, Ривест. Алгоритмы: построение и анализ.\\ 
\hspace*{16pt} \href{https://lib.mipt.ru/book/16736/}{lib.mipt.ru/book/16736/}
\item Керниган Ритчи Язык программирования C \\
\hspace*{16pt} \href{https://lib.mipt.ru/book/266005/}{lib.mipt.ru/book/266005/}
\item Простое введение в алгоритмы hexlet.io. \\ \hspace*{16pt} \href{https://www.youtube.com/watch?v=8JlTwMg1dyw&list=PLwwk4BHih4fjIT5cT4i1s93b99aJScUGB}{youtube.com/watch?v=8JlTwMg1dyw\&list=PLwwk4BHih4fjIT5cT4i1s93b99aJScUGB}
\item Лекторий МФТИ: \\ \hspace*{16pt} 
\href{http://lectoriy.mipt.ru/course/ComputerTechnology-Informatics-14L#lectures}
{lectoriy.mipt.ru/course/ComputerTechnology-Informatics-14L\#lectures}
\item Курс по структурам данных stepic.org  \\
\hspace*{16pt} \href{https://www.youtube.com/watch?v=vRvSdWVst54}{youtube.com/watch?v=vRvSdWVst54}
\item Продвинутый уровень. Язык C и структуры данных в Йелле.\\ \hspace*{16pt} \href{http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html}{www.cs.yale.edu/homes/aspnes/classes/223/notes.html}
\end{enumerate}

\subsection*{2-й семестр:}
\begin{enumerate}
\item Кормен, Лейзерсон, Ривест. Алгоритмы: построение и анализ.\\ 
\hspace*{16pt} \href{https://lib.mipt.ru/book/16736/}{lib.mipt.ru/book/16736/}
\item learncpp:\\ 
\hspace*{16pt} \href{http://www.learncpp.com/}{http://www.learncpp.com/}
\item Код с лекций:\\ 
\hspace*{16pt} \href{https://github.com/avasyukov/oop-2nd-term/tree/master/2018}{https://github.com/avasyukov/oop-2nd-term/tree/master/2018}

\end{enumerate}

\subsubsection*{Дополнительные материалы по некоторым вопросам:}
\begin{itemize}

\item Вопрос №10. Сегменты памяти:\\
\href{https://www.youtube.com/watch?v=_8-ht2AKyH4}{youtube.com/watch?v=\_8-ht2AKyH4}  (англ.)\\
\href{https://tproger.ru/translations/programming-concepts-stack-and-heap/}{tproger.ru/translations/programming-concepts-stack-and-heap/}
\item Вопрос №11. Этапы компиляции:\\
\href{https://www.youtube.com/watch?v=ylA55D4B4_M}{youtube.com/watch?v=ylA55D4B4\_M}

\end{itemize}
\end{document}