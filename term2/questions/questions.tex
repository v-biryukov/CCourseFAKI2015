\documentclass{article}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{amsmath} 
\usepackage{amsfonts}
\usepackage{upgreek}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{geometry}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{ccaption}



\begin{document}
\pagenumbering{gobble}

\section*{Теория:}
\begin{enumerate}

\section*{Часть 1:}

\item \textbf{Пространство имён и ссылки}\\
Пространство имён: что такое и зачем нужно. \texttt{using}-объявление. Анонимное пространство имён. Что такое ссылки. Различие ссылок и указателей. Ссылки на константу. Три типа передачи аргументов в функцию: передача по значению, передача по ссылке и передача по ссылке на константу. Преимущества/недостатки каждого метода. Возвращение ссылки из функции.




\item  \textbf{Перегрузка функций}\\
Сигнатуры функций в языках C и C++. Перегрузка функций. Манглирование имён. Ключевое слово \texttt{extern "C"}. Правила разрешения перегрузки функций. 


\item \textbf{Перегрузка операторов}\\
Перегрузка операторов в языке C++. Перегрузка арифметических операторов. Перегрузка унарных операторов. Перегрузка операторов как методов класса. Перегрузка оператора присваивания. Перегрузка оператора присваивания сложения. Реализация оператора сложения с помощью оператора присваивания сложения (\texttt{+=}). Перегрузка операторов ввода вывода \verb|<<| и \verb|>>| с \texttt{cin} и \texttt{cout}. Перегрузка оператора взятия индекса. Перегрузка операторов инкремента и декремента. Перегрузка оператора стрелочка (\texttt{->}). Перегрузка операторов \texttt{new} и \texttt{delete}. Перегрузка оператора вызова функции.

\item  \textbf{Классы. Инкапсуляция}\\
Что такое объектно-ориентированное программирование. Основные принципы ООП: инкапсуляция, композиция, наследование и полиморфизм. Классы. Поля и методы класса. Константные методы класса. Модификаторы доступа \texttt{private} и \texttt{public}.  Указатель \texttt{this}.  Различие ключевых слов \texttt{struct} и \texttt{class} в языке C++. Конструкторы и деструкторы. Список инициализации членов класса. Какие поля можно инициализировать с помощью списка инициализации, но нельзя инициализировать обычным образом. Перегрузка конструкторов. Конструктор по умолчанию. Конструктор копирования. Делегирующий конструктор. Ключевое слово \texttt{explicit}. Перегрузка оператора присваивания. Конструкторы и перегруженные операторы, создаваемые по умолчанию.
Друзья. Ключевое слово \texttt{friend}. 

\item \textbf{Инициализация, ключевое слово auto и другое}\\
Инициализация. Default initialization. Value initialization. Direct initialization. Direct list initialization. Copy initialization. Copy list initialization. Ключевое слово \texttt{auto}. Range-based циклы. Пользовательские литералы. Structure bindings. Copy elision. Return value optimization.

\item  \textbf{Динамическое создание объектов в Куче}\\
Создание экземпляров класса в стеке и куче в языке C++. Использование операторов \texttt{new} и \texttt{delete}. Основные отличия \texttt{new} и \texttt{delete} от \texttt{malloc} и \texttt{free}. Операторы \texttt{new[]} и \texttt{delete[]}. Создание массива объектов в Куче. Оператор \texttt{placement new}.

\item \textbf{Реализация строки. Классы \texttt{std::string} и \texttt{std::string\_view}}\\
Реализация своей строки с выделением памяти в Куче.
Методы такой строки:
\begin{itemize}
\item Конструктор по умолчанию
\item Конструктор, принимающий строку в стиле C (\texttt{const char*})
\item Конструктор копирования
\item Деструктор
\item Оператор присваивания
\item Оператор сложения
\item Оператор присваивания сложения(\texttt{+=}).
\end{itemize}

Стандартная строка \texttt{std::string}. Преимущества строки \texttt{std::string} по сравнению со строкой в стиле \texttt{C}. Класс \texttt{std::string\_view}. Строение объектов этого класса, его размер. Конструкторы этого класса. Методы \texttt{remove\_prefix} и \texttt{remove\_suffix}. В чём преимущество передачи \texttt{string\_view} в функцию. Опасность возврата \texttt{string\_view} из функции.

\item \textbf{Шаблоны.}\\
Шаблонные функции. Использование шаблонных функции в языке C++. Шаблоны классов. Инстанцированием шаблона. Вывод шаблонных аргументов функций и классов. Специализация шаблона.

\item \textbf{STL. Контейнеры \texttt{std::vector} и \texttt{std::array}}\\
Контейнер \texttt{std::vector}. С помощью какой структуры данных реализован. Как устроен вектор, где и как хранятся данные в векторе. Размер и вместимость вектора, методы \texttt{resize} и \texttt{reserve}. Методы \texttt{push\_back}, \texttt{pop\_back}, \texttt{insert}, \texttt{erase} и их вычислительная сложность. Когда происходит инвалидация итераторов вектора? Контейнер \texttt{std::array}. Как устроен, где и как хранятся данные в массиве.

\item \textbf{STL. Итераторы}\\
Идея итераторов. В чём преимущество итераторов по сравнению с обычным обходом структур данных. Операции, которые можно производить с итератором. Категории итераторов (Random access, Biderectional, Forward, Output, Input). Обход стандартных контейнеров с помощью итераторов. Константные и обратные итераторы. Методы \texttt{begin}, \texttt{end}, \texttt{cbegin}, \texttt{cend} и другие. Итератор \texttt{std::back\_insert\_iterator}. Использование функции \texttt{std::copy} для вставки элементов в контейнер. Итератор \texttt{std::ostream\_iterator}. Функции \texttt{std::advance}, \texttt{std::next} и \texttt{std::distance}. 

\item \textbf{STL. Контейнеры \texttt{std::list} и \texttt{std::deque}}\\
С помощью какой структуры данных реализован. Как устроен список, где и как хранятся данные в списке. Методы списка: \texttt{insert}, \texttt{erase}, \texttt{push\_back}, \texttt{push\_front}, \texttt{pop\_back}, \texttt{pop\_front}. Вычислительная сложность этих операций. Когда происходит инвалидация итераторов списка? Как удаляются элементы списка во время прохода по нему. Контейнер \texttt{std::deque}, как реализован, операций, которые можно с ним провести и их вычислительная сложность. Когда происходит инвалидация итераторов deque? Контейнеры адаптеры \texttt{std::stack}, \texttt{std::queue} и \texttt{std::priority\_queue}.

\item \textbf{STL. Контейнеры-множества}\\
Контейнер \texttt{std::set} -- множество. Его основные свойства. С помощью какой структуры данных он реализован. Методы \texttt{insert}, \texttt{erase}, \texttt{find}, \texttt{count}, \texttt{lower\_bound}, \texttt{upper\_bound} и их вычислительная сложность. Можно ли изменить элемент множества? Контейнер \texttt{std::unordered\_set} -- неупорядоченное множество. Его основные свойства. С помощью какой структуры данных он реализован. Основные методы этого контейнера и их вычислительная сложность. Когда происходит инвалидация итераторов множества?

\item \textbf{STL. Контейнеры-словари}\\
Контейнер \texttt{std::map} -- словарь. Его основные свойства. Методы \texttt{insert}, \texttt{operator[]}, \texttt{erase}, \texttt{find}, \texttt{count}, \texttt{lower\_bound}, \texttt{upper\_bound} и их вычислительная сложность. Контейнер \texttt{std::unordered\_map}. С помощью какой структуры данных этот контейнер реализован. Его основные свойства и методы и их вычислительная сложность. Как изменить ключ элемента словаря?  Когда происходит инвалидация итераторов словаря? Пользовательский компаратор для упорядоченных ассоциативных контейнеров. Контейнеры \texttt{multumap} и \texttt{unordered\_multumap}. Как удалить из \texttt{multimap} все элементы с данным ключом. Как удалить из \texttt{multimap} только один элемент с данным ключом? Пользовательский компаратор и пользовательская хеш-функция для неупорядоченнных ассоциативных контейнеров.




\item \textbf{Move-семантика.}\\
Глубокое копирование и поверхностное копирование. Копирование объекта. Перемещение объекта. Стандартная функция \texttt{std::move}. В чём преимущества перемещения над копированием? Перемещение объекта в функцию, если функция принимает объект по значению. Перемещение объекта при возврате из функции. Что такое выражение? lvalue-выражения и rvalue-выражения. Приведите примеры lvalue и rvalue выражений. 

\item \textbf{Умные указатели.}\\
Недостатки обычных указателей. Умный указатель \texttt{std::unique\_ptr}. Шаблонная функция \texttt{std::make\_unique}. Перемещение объектов типа \texttt{unique\_ptr}. Умный указатель \texttt{std::shared\_ptr}. Работа с таким указателем. Шаблонная функция \texttt{std::make\_shared}. Базовая реализация \texttt{std::shared\_ptr}. Умный указатель \texttt{std::weak\_ptr}.


\item \textbf{rvalue-ссылки и универсальные ссылки}\\
Что такое lvalue ссылки, а что такое rvalue ссылки, в чём разница? Зачем нужно разделение выражений на lvalue и rvalue. rvalue-ссылки. Что на самом деле делает функция \texttt{std::move}? Конструктор перемещения и оператор присваивания перемещения. Создание класса, с пользовательским конструктором перемещения и пользовательским оператором перемещения. Правило пяти.  Правила свёртки ссылок. Универсальные ссылки, чем они отличаются от lvalue и rvalue ссылок? Реализация функции \texttt{std::move}. Идеальная передача. Функция \texttt{std::forward}.


\newpage
\section*{Часть 2:}

\item \textbf{Раздельная компиляция}\\
Что такое файл исходного кода и исполняемый файл. Этап сборки программы: препроцессинг, ассемблирование, компиляция и линковка. Директивы препроцессора \texttt{\#include} и \texttt{\#define}. Компиляция программы с помощью \texttt{g++}. Header-файлы. Раздельная компиляция. Преимущества раздельной компиляции. Статические библиотеки и их подключение с помощью компилятора \texttt{gcc}. Динамические библиотеки и их подключение.

\item \textbf{Событийно-ориентированное программирование и библиотека SFML}\\
Библиотека SFML. Класс \texttt{sf::RenderWindow}. Системы координат SFML (координаты пикселей, глобальная система координат, локальные системы координат). Методы \texttt{mapPixelToCoords} и \texttt{mapCoordsToPixel}. Основной цикл программы. Двойная буферизация. Понятие событий. Событийно-ориентированное программирование. События SFML: \texttt{Closed}, \texttt{Resized}, \texttt{KeyPressed}, \texttt{KeyReleased}, \texttt{MouseButtonPressed},  \texttt{MouseButtonReleased}, \texttt{MouseMoved}. Очередь событий. Цикл обработки событий.


\item \textbf{Наследование.}\\
Наследование в языке \texttt{C++}. Добавление новых полей и методов в наследуемый класс. Вызов конструкторов наследуемого класса. Модификатор доступа \texttt{protected}. Переопределение методов. Чем отличается переопределение от перегрузки? Ключевые слова \texttt{override} и \texttt{final}. Чистые виртуальные функции. Абстрактные классы и интерфейсы.  Срезка объектов. Множественное наследование. Виртуальное множественное наследование.

\item \textbf{Полиморфизм.}\\
Полиморфизм в \texttt{C++}. Указатели на базовый класс, хранящие адрес объекта наследуемого класса.  Виртуальные функции. Реализация механизма виртуальных функций. Таблица виртуальных функций. Виртуальный деструктор. Статический и динамический типы. Хранение объектов разных динамических типов в векторе. Оператор \texttt{dynamic\_cast}. В каких случая он используется? Что происходит если \texttt{dynamic\_cast} не может привести тип? Рассмотрите случай приведения указателей и случай приведения ссылок.
Использование \texttt{static\_cast} для приведения типов и указателей на типы в иерархии наследования. 


\item \textbf{Функциональные объекты}\\
Указатели на функции в алгоритмах STL. Функторы. Стандартные функторы: \texttt{std::less}, \texttt{std::greater}, \texttt{std::equal\_to}, \texttt{std::plus}, \texttt{std::minus}, \texttt{std::multiplies}. Основы лямбда-функций. Стандартные алгоритмы STL, принимающие функциональные объекты. Тип обёртка \texttt{std::function}. Шаблонная функция \texttt{std::bind}.

\item \textbf{Лямбда-функций}\\
Лямбда-функций. Объявление лямбда-функций. Передача их в другие функции. Преимущества лямбда-функций перед указателями на функции и функторами. Использование лямбда функций со стандартными алгоритмами \texttt{std::sort}, \texttt{std::transform}, \texttt{str::copy\_if}. Лямбда-захват. Захват по значению и по ссылке. Захват всех переменных области видимости по значению и по ссылке. Объявление новых переменных внутри захвата.


\item \textbf{Методы обработки ошибок.}\\
Классификация ошибок. Ошибки времени компиляции, ошибки линковки, ошибки времени выполнения, логические ошибки.
Виды ошибок времени выполнения: внутренние и внешние ошибки. Методы борьбы с ошибками: \texttt{assert}, использование глобальной переменной, коды возврата и исключения. Преемущества и недостатки каждого из этих методов. Какие из этих методов желательно использовать для внутренних ошибок, а какие для внешних?


\item \textbf{Исключения.}\\
Зачем нужны исключения, в чём их преимущество перед другими методами обработки ошибок?
Оператор \texttt{throw}, аргументы каких типов может принимать данный оператор. Что происходит после достижения программы оператора \texttt{throw}. Раскручивание стека. Блок \texttt{try-catch}. Что произойдёт, если выброшенное исключение не будет поймано? Стандартные классы исключений: \texttt{std::exception}, \texttt{std::runtime\_error}, \texttt{std::bad\_alloc}, \texttt{std::bad\_cast}, \texttt{std::logic\_error}. Почему желательно ловить стандартные исключение по ссылке на базовый класс \texttt{std::exception}? Использование \texttt{catch} для ловли всех типов исключений. Использование исключений в кострукторах, деструкторах, перегруженных операторах. Спецификатор \texttt{noexcept}. Гарантии безопасности исключений. Исключения при перемещении объектов. \texttt{move\_if\_noexcept}. Идиома \texttt{copy and swap}.



\item \textbf{Реализация вектора.}\\
Реализация своего вектора \texttt{mipt::Vector<T>} (аналога \texttt{std::vector<T>}). Нужно также предусмотреть итераторы этого вектора: \texttt{mipt::Vector<T>::iterator}, а также константные и обратные итераторы.\\
Методы такого вектора:
\begin{itemize}
\item Конструктор по умолчанию
\item Конструктор, принимающий количество элементов
\item Конструктор, принимающий количество элементов и значение элемента
\item Конструктор от \texttt{std::initializer\_list}.
\item Конструктор копирования
\item Конструктор перемещения
\item Деструктор
\item Оператор присваивания копирования
\item Оператор присваивания перемещения
\item Оператор взятия индекса (\texttt{operator[]})
\item Метод \texttt{at}, аналог метода \texttt{at} класса \texttt{std::vector}

\item Методы \texttt{size}, \texttt{capacity}, \texttt{empty}, \texttt{reserve}, \texttt{resize}, \texttt{shrink\_to\_fit}.
\item Методы \texttt{push\_back}, \texttt{emplace\_back}, \texttt{pop\_back}.

\item Методы для работы с итераторами \texttt{begin}, \texttt{end}, \texttt{rbegin}, \texttt{rend}.
\end{itemize}

Безопасность относительно исключений у такого вектора.




\item \textbf{Система типов языка \texttt{C++}.}\\
Система типов языка \texttt{C++}. Встроенные типы, массивы, структуры, объединения, перечисления, классы, указатели, ссылки, функциональные объекты (функции, указатели и ссылки на функции, функторы, лямбда-функции), указатели на члены класса, битовые поля. Вывод типа выражения с помощью \texttt{decltype}. Различие вывода с помощью \texttt{decltype}, \texttt{auto} и вывода шаблонных аргументов. Разложение типов (type decay) и когда он происходит.


\item \textbf{Приведение типов}\\
В чём недостатки приведения в стиле \texttt{C}? Оператор \texttt{static\_cast} и в каких случая он используется. Операторы \texttt{reinterpret\_cast} и \texttt{const\_cast} и в каких случая они используется. 

\item \textbf{Классы \texttt{std::any}, \texttt{std::optional} и \texttt{std::variant}}\\
Класс \texttt{std::any}. Функция \texttt{std::any\_cast}. Класс \texttt{std::optional}. Методы класса \texttt{std::optional}:
\begin{itemize}
\item Конструкторы
\item Методы \texttt{value}, \texttt{has\_value}, \texttt{value\_or}.
\item Унарные операторы \texttt{*} и \texttt{->}
\item Оператор преобразования к значению типа \texttt{bool}.
\end{itemize}
Для чего можно применять \texttt{std::optional}?

Класс \texttt{std::variant}. Функции для работы с \texttt{std::variant}:
\begin{itemize}
\item \texttt{std::get}
\item \texttt{std::holds\_alternative}
\item \texttt{std::visit}
\end{itemize}
Для чего можно применять \texttt{std::variant}?


\item \textbf{Вычисления на этапе компиляции. \texttt{constexpr}} \\
Вычисление на этапе компиляции. В чём преимущества вычисления на этапе компиляции по сравнению с вычислением на этапе выполнения.  Ключевое слово \texttt{constexpr}. Что означает \texttt{constexpr} при объявлении переменной? Что означает \texttt{constexpr} при определении функции? Разница между \texttt{const} и \texttt{constexpr}. Ключевые слова \texttt{consteval} и \texttt{constinit}. \texttt{static\_assert}.


\item \textbf{Вычисления на этапе компиляции. Шаблонное метапрограммирование.} \\
Полная специализация шаблона. Частичная специализация шаблона. Что такое шаблонные метафункции и зачем они нужны? Использование специализации шаблона для написание следующих метафункций:
\begin{itemize}
\item \texttt{IsInt} - проверяет, является ли тип \texttt{T} типом \texttt{int}.
\item \texttt{IsIntegral} - проверяет, является ли тип \texttt{T} целочисленным типом.
\item \texttt{IsPointer} - проверяет, является ли тип \texttt{T} указателем.
\item \texttt{IsSame} - проверяет, являются ли 2 типа \texttt{T1} и \texttt{T2} одинаковыми.
\item \texttt{RemovePointer} - если тип \texttt{T} является указателем, то возвращает тип того, на что такой указатель указывает (то есть убирает одну "звёздочку" у типа).
\item \texttt{IsHasBegin} - проверяет, есть ли у типа \texttt{T} метод begin.
\end{itemize}
Что такое концепты, как их использовать и зачем они нужны?



\end{enumerate}

\end{document}