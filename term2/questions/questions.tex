\documentclass{article}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{amsmath} 
\usepackage{amsfonts}
\usepackage{upgreek}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{geometry}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{ccaption}
\usepackage{mathrsfs}
\usepackage[shortlabels]{enumitem}
\usepackage{listings}
\lstset{
  language=C,                % choose the language of the code
  basicstyle=\linespread{1.1}\ttfamily,
  columns=fixed,
  fontadjust=true,
  basewidth=0.5em,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray},
  stringstyle=\ttfamily\color{orange!50!black},
  showstringspaces=false,
  %numbers=false,                   % where to put the line-numbers
  numbersep=5pt,
  numberstyle=\tiny\color{black},
  numberfirstline=true,
  stepnumber=1,                   % the step between two line-numbers.        
  numbersep=10pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
  showstringspaces=false,         % underline spaces within strings
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=true,         % sets if automatic breaks should only happen at whitespace
  xleftmargin=.2in,
  extendedchars=\true,
  keepspaces = true,
}
\lstset{literate=%
   *{0}{{{\color{red!20!violet}0}}}1
    {1}{{{\color{red!20!violet}1}}}1
    {2}{{{\color{red!20!violet}2}}}1
    {3}{{{\color{red!20!violet}3}}}1
    {4}{{{\color{red!20!violet}4}}}1
    {5}{{{\color{red!20!violet}5}}}1
    {6}{{{\color{red!20!violet}6}}}1
    {7}{{{\color{red!20!violet}7}}}1
    {8}{{{\color{red!20!violet}8}}}1
    {9}{{{\color{red!20!violet}9}}}1
}


\begin{document}
\pagenumbering{gobble}

\section*{Модуль 2. Вопросы.}
\begin{enumerate}

\item \textbf{Move семантика}
\begin{enumerate}[a.]

\item \textbf{Перемещение}\\
Что понимается под копированием объекта в C++? Что происходит при копировании? Что понимается под перемещением объекта в C++? Что происходит при перемещении? Стандартная функция \texttt{std::move}. В чём преимущества перемещения над копированием? Перемещение объекта в функцию, если функция принимает объект по значению. Как происходит перемещение объектов встроенных типов и объектов классов? Что происходит при перемещении объекта класса \texttt{std::vector}? Перемещение объекта при возврате из функции и взаимодействие такого перемещения с RVO.


\item \textbf{lvalue-выражения и rvalue-выражения}\\
Что такое выражение? Тип выражения и категория выражения. Что такое lvalue-выражение? Что такое rvalue-выражение? Приведите примеры lvalue и rvalue выражений.


\item \textbf{lvalue-ссылки и rvalue-ссылки}\\
Что такое lvalue-ссылки, а что такое rvalue-ссылки, в чём разница? Зачем нужно разделение выражений на lvalue и rvalue. Перегрузка по категории выражения. Уметь написать функцию, которая печатает категорию переданого ей выражения. Какую категорию имеет выражение, состоящее только из одного идентификатора -- rvalue-ссылки? Что на самом деле делает функция \texttt{std::move}?

\item \textbf{Особые методы, связанные с перемещением}\\
Конструктор перемещения и оператор присваивания перемещения. Создание класса, с пользовательским конструктором перемещения и пользовательским оператором перемещения. Правило пяти. Идиома Move-and-Swap.

\item \textbf{Умный указатель \texttt{std::unique\_ptr}}\\
Зачем нужен умный указатель \texttt{std::unique\_ptr}? В чём его преемущество по сравнению с обычными указателями? Реализация \texttt{std::unique\_ptr}. Шаблонная функция \texttt{std::make\_unique}. Перемещение объектов типа \texttt{unique\_ptr}. Передача таких указателей в функции. Нужно уметь писать класс, аналогичный классу \texttt{std::unique\_ptr}. Циклические ссылки и \texttt{std::unique\_ptr}.

\item \textbf{Умный указатель \texttt{std::shared\_ptr}}\\
Зачем нужен умный указатель \texttt{std::shared\_ptr}? В чём его преемущество по сравнению с обычными указателями и с \texttt{std::unique\_ptr}? Шаблонная функция \texttt{std::make\_shared}. Как схематически устроен указатель типа \texttt{std::shared\_ptr}. Циклические ссылки и \texttt{std::shared\_ptr}. Умный указатель \texttt{std::weak\_ptr}.

\end{enumerate}

\item \textbf{Сборка}
\begin{enumerate}[a.]
\item \textbf{Раздельная компиляция}\\
Что такое файл исходного кода и исполняемый файл? Этап сборки программы: препроцессинг, ассемблирование, компиляция и линковка. Что такое заголовочные файлы (header-файлы)? Что делает директива препроцессора \texttt{\#include}? Что такое единица трансляции? Компиляция программы с помощью \texttt{g++}. Опции компиляции \texttt{-E}, \texttt{-S} и \texttt{-c}. Что такое раздельная компиляция и в чём её преемущества?


\item \textbf{Библиотеки}\\
Что такое библиотека? Виды библиотек: header-only библиотеки, open-source библиотеки, статические библиотеки, динамические библиотеки. В чём различия между этими видами библиотек? В чём преимущества и недостатки каждого из видов библиотек? Как подключить библиотеки к своему проекту? 

\item \textbf{Статические библиотеки}\\
Как создать статическую библиотеку? Как подключить статическую библиотеку? Опции компилятора \texttt{-I}, \texttt{-L} и \texttt{-l}. Характерные расширения файлов статических библиотек на Linux и Windows. 

\item \textbf{Динамические библиотеки}\\
В чём главная разница между статическими и динамическими библиотеками? Как создать динамическую библиотеку? Как подключить динамическую библиотеку? Характерные расширения файлов динамических библиотек на Linux и Windows. 

\item \textbf{Bash-скрипты. Основы Make. Основы CMake}\\
Использование Bash-скриптов(на Linux) или Bat-скриптов(на Windows) для оптимицации сборки программы. Основы Make и использование этой утилиты для сборки простейшей программы. Основы CMake и использование этой утилиты для сборки простейшей программы.
\end{enumerate}


\newpage
\item \textbf{Событийно-ориентированное программирование}
\begin{enumerate}[a.]
\item \textbf{Библиотека SFML. Отрисовка на экран}\\
Класс \texttt{sf::RenderWindow}. Классы \texttt{sf::CircleShape} и \texttt{sf::RectangleShape} и основные методы этих классов (в частности метод \texttt{setOrigin}). Системы координат SFML (координаты пикселей, глобальная система координат, локальные системы координат). Методы \texttt{mapPixelToCoords} и \texttt{mapCoordsToPixel} класса \texttt{sf::RenderWindow}. Основной цикл программы. Двойная буферизация. Методы \texttt{clear}, \texttt{draw} и \texttt{display} класса \texttt{sf::RenderWindow}. 

\item \textbf{Событийно-ориентированное программирование}\\
Понятие событий. Событийно-ориентированное программирование. Очередь событий. Цикл обработки событий.

\item \textbf{Событийно-ориентированное программирование в библиотеке SFML}\\
Класс \texttt{sf::Event} и цикл обработки событий в SFML.
События SFML: \texttt{Closed}, \texttt{Resized}, \texttt{KeyPressed}, \texttt{KeyReleased}, \texttt{MouseButtonPressed},  \texttt{MouseButtonReleased}, \texttt{MouseMoved}.

Функции \texttt{sf::Keyboard::isKeyPressed} и \texttt{sf::Mouse::isButtonPressed}. Чем использование этих функций отличается от использования событий?
\end{enumerate}





\item \textbf{Наследование}
\begin{enumerate}[a.]
\item \textbf{Основы наследования}\\
Наследование в языке \texttt{C++}. Добавление новых полей и методов в наследуемый класс. Модификатор доступа \texttt{protected}. Публичное и приватное наследование. Имеют ли друзья базового класса доступ к приватным полям класса-наследника? 
Порядок вызовов конструкторов при создании экземпляра класса-наследника. Как сделать так, чтобы вызывалась необходимая перегрузка конструктора базового класса при создании экземпляра класса-наследника.

\item \textbf{Перегрузка и переопределение методов в классе наследнике}\\
Перегрузка методов в базовом и наследуемом классе. Как проходит отбор перегрузки? Переопределение  методов в классе-наследнике. Разница между перегрузкой и переопределением. Вызов методов базового класса из класса наследника.

\item \textbf{Приведение типов}\\
Присваивание объекта класса наследника объекту базового класса (\texttt{base = derived}). Срезка.
Строение объекта класса-наследника. Размер объекта класса-наследника. Empty base optimisation. Присваивание указателя на объект класса наследника указателю базового класса (\texttt{pbase = pderived}).
Иерархия наследования. Использование \texttt{static\_cast} для перемещения по иерархии наследования. В каких случах это может привести к неопределённому поведению?


\item \textbf{Множественно наследование}\\
Строение объекта класса наследника при обычном (не виртуальном) множественном наследовании.
Сдвиг указателей при присваивании в случае множественного наследования. Ромбовидное наследование. Как в языке C++ решается проблема ромбовидного наследования?
\end{enumerate}




\item \textbf{Полиморфизм}
\begin{enumerate}[a.]


\item \textbf{Основы полиморфизма}\\
Статический полиморфизм в языке C++ и других языках. Динамический полиморфизм и его примеры в других языках(например, в языке Python). Для чего нужен полиморфизм? 


\item \textbf{Основы динамического полиморфизма в языке C++}\\
Указатели на базовый класс, хранящие адрес объекта наследуемого класса (\texttt{Base* pbase = \&derived}). Методы какого класса будут вызываться, если мы будем вызывать их через такой указатель?  Виртуальные функции. Виртуальный деструктор. Ключевые слова \texttt{override} и \texttt{final}. Уметь написать пример использования полиморфизма (например, вектор указателей типа \texttt{Base*}). Приватность и виртуальные функции.

\item \textbf{Абстрактные классы}\\
Чистая виртуальная функция. Абстрактный класс. Интерфейс. Наследование от интерфейса. Ошибка pure virtual call.

\item \textbf{dynamic\_cast}\\
Полиморфные типы.  Использование \texttt{static\_cast} для приведения типов и указателей на типы в иерархии наследования. Когда использование \texttt{static\_cast} может привести к неопределённому поведению? Оператор \texttt{dynamic\_cast}. Чем он отличается от \texttt{static\_cast} и в каких случая он используется? Что происходит если \texttt{dynamic\_cast} не может привести тип (рассмотрите случай приведения указателей и случай приведения ссылок)?.


\item \textbf{Реализация механизма виртуальных функций}\\
Скрытое поле - указатель на таблицу виртуальных функций.
Сколько таблиц виртуальных функций хранится в памяти при работе программы? Как устроены таблицы виртуальных функций?
\end{enumerate}




\item \textbf{Паттерны проектирования}
\begin{enumerate}[a.]
\item \textbf{Основы}\\
Что такое паттерны проектирования? Зачем нужно использовать паттерны проектирования. UML-диаграммы. Отношения между классами: наследование, композиция, агрегация, ассоциация и дружественность.


\item \textbf{Стратегия}\\
Паттерн стратегия. Какие преемущества даёт использование этого паттерна? Пример использования этого паттерна.

\item \textbf{Машина состояний}\\
Паттерн состояние. Паттерн машина состояний. Какие преемущества даёт использование этих паттернов перед использованием объекта перечисляемого типа?  Пример использования этих паттернов.
\end{enumerate}


\item \textbf{Обработка ошибок}
\begin{enumerate}[a.]
\item \textbf{Методы обработки ошибок.}\\
Классификация ошибок. Ошибки времени компиляции, ошибки линковки, ошибки времени выполнения, логические ошибки.
Виды ошибок времени выполнения: внутренние и внешние ошибки. Методы борьбы с ошибками: макрос \texttt{assert}, использование глобальной переменной(\texttt{errno}), коды возврата и исключения. Преемущества и недостатки каждого из этих методов. Какие из этих методов желательно использовать для внутренних ошибок, а какие для внешних?


\item \textbf{assert}\\
Макрос \texttt{assert} и его применения для обнаружения ошибок.

\item \textbf{Коды возврата и класс \texttt{std::optional}}\\
Обработка ошибок с помощью кодов возврата. Примеры стандартных фуцнкий, использующих коды возврата.
Класс \texttt{optional} из стандартной библиотеки.
Методы класса \texttt{optional}:
\begin{itemize}
\item Конструкторы
\item Методы \texttt{value}, \texttt{has\_value}, \texttt{value\_or}.
\item Унарные операторы \texttt{*} и \texttt{->}
\item Оператор преобразования к значению типа \texttt{bool}.
\end{itemize}
Для чего можно применять \texttt{std::optional}? Использование класса \texttt{optional} для обработки ошибок с помощью кодов возврата.


\item \textbf{Исключения.}\\
Зачем нужны исключения, в чём их преимущество перед другими методами обработки ошибок?
Оператор \texttt{throw}, аргументы каких типов может принимать данный оператор. Что происходит после достижения программы оператора \texttt{throw}. Раскручивание стека. Блок \texttt{try-catch}. Что произойдёт, если выброшенное исключение не будет поймано? Стандартные классы исключений: \texttt{std::exception}, \texttt{std::runtime\_error}, \texttt{std::bad\_alloc}, \texttt{std::bad\_cast}, \texttt{std::logic\_error}. Почему желательно ловить стандартные исключение по ссылке на базовый класс \texttt{std::exception}? Использование \texttt{catch} для ловли всех типов исключений. Использование исключений в кострукторах, деструкторах, перегруженных операторах. Спецификатор \texttt{noexcept}. Гарантии безопасности исключений. Исключения при перемещении объектов. \texttt{move\_if\_noexcept}. Идиома \texttt{copy and swap}.

\end{enumerate}
\end{enumerate}














\ifx

\begin{enumerate}

\item \textbf{Паттерны проектирования с использованием шаблонов}
\begin{enumerate}[a.]
\item \textbf{Класс \texttt{any} из стандартной библиотеки}\\
Класс \texttt{any}. Функция \texttt{any\_cast}. 


\item \textbf{Класс \texttt{variant} из стандартной библиотеки}\\
Функции для работы с \texttt{variant}:
\begin{itemize}
\item \texttt{get}
\item \texttt{holds\_alternative}
\item \texttt{visit}
\end{itemize}
Для чего можно применять \texttt{variant}? Динамический полиморфизм при использовании класса \texttt{variant}.

\item \textbf{Type erasure}\\
Паттерн Type erasure (Стирание типа). Реализация своего класса \texttt{any} при помощи паттерна Type erasure.
\end{enumerate}

\item \textbf{Функциональные объекты}\\
Указатели на функции в алгоритмах STL. Функторы. Стандартные функторы: \texttt{std::less}, \texttt{std::greater}, \texttt{std::equal\_to}, \texttt{std::plus}, \texttt{std::minus}, \texttt{std::multiplies}. Основы лямбда-функций. Стандартные алгоритмы STL, принимающие функциональные объекты. Тип обёртка \texttt{std::function}. Шаблонная функция \texttt{std::bind}.

\item \textbf{Лямбда-функций}\\
Лямбда-функций. Объявление лямбда-функций. Передача их в другие функции. Преимущества лямбда-функций перед указателями на функции и функторами. Использование лямбда функций со стандартными алгоритмами \texttt{std::sort}, \texttt{std::transform}, \texttt{str::copy\_if}. Лямбда-захват. Захват по значению и по ссылке. Захват всех переменных области видимости по значению и по ссылке. Объявление новых переменных внутри захвата.







\item \textbf{Реализация вектора.}\\
Реализация своего вектора \texttt{mipt::Vector<T>} (аналога \texttt{std::vector<T>}). Нужно также предусмотреть итераторы этого вектора: \texttt{mipt::Vector<T>::iterator}, а также константные и обратные итераторы.\\
Методы такого вектора:
\begin{itemize}
\item Конструктор по умолчанию
\item Конструктор, принимающий количество элементов
\item Конструктор, принимающий количество элементов и значение элемента
\item Конструктор от \texttt{std::initializer\_list}.
\item Конструктор копирования
\item Конструктор перемещения
\item Деструктор
\item Оператор присваивания копирования
\item Оператор присваивания перемещения
\item Оператор взятия индекса (\texttt{operator[]})
\item Метод \texttt{at}, аналог метода \texttt{at} класса \texttt{std::vector}

\item Методы \texttt{size}, \texttt{capacity}, \texttt{empty}, \texttt{reserve}, \texttt{resize}, \texttt{shrink\_to\_fit}.
\item Методы \texttt{push\_back}, \texttt{emplace\_back}, \texttt{pop\_back}.

\item Методы для работы с итераторами \texttt{begin}, \texttt{end}, \texttt{rbegin}, \texttt{rend}.
\end{itemize}

Безопасность относительно исключений у такого вектора.




\item \textbf{Система типов языка \texttt{C++}.}\\
Система типов языка \texttt{C++}. Встроенные типы, массивы, структуры, объединения, перечисления, классы, указатели, ссылки, функциональные объекты (функции, указатели и ссылки на функции, функторы, лямбда-функции), указатели на члены класса, битовые поля. Вывод типа выражения с помощью \texttt{decltype}. Различие вывода с помощью \texttt{decltype}, \texttt{auto} и вывода шаблонных аргументов. Разложение типов (type decay) и когда он происходит.


\item \textbf{Приведение типов}\\
В чём недостатки приведения в стиле \texttt{C}? Оператор \texttt{static\_cast} и в каких случая он используется. Операторы \texttt{reinterpret\_cast} и \texttt{const\_cast} и в каких случая они используется. 




\item \textbf{Вычисления на этапе компиляции. \texttt{constexpr}} \\
Вычисление на этапе компиляции. В чём преимущества вычисления на этапе компиляции по сравнению с вычислением на этапе выполнения.  Ключевое слово \texttt{constexpr}. Что означает \texttt{constexpr} при объявлении переменной? Что означает \texttt{constexpr} при определении функции? Разница между \texttt{const} и \texttt{constexpr}. Ключевые слова \texttt{consteval} и \texttt{constinit}. \texttt{static\_assert}.


\item \textbf{Вычисления на этапе компиляции. Шаблонное метапрограммирование.} \\
Полная специализация шаблона. Частичная специализация шаблона. Что такое шаблонные метафункции и зачем они нужны? Использование специализации шаблона для написание следующих метафункций:
\begin{itemize}
\item \texttt{IsInt} - проверяет, является ли тип \texttt{T} типом \texttt{int}.
\item \texttt{IsIntegral} - проверяет, является ли тип \texttt{T} целочисленным типом.
\item \texttt{IsPointer} - проверяет, является ли тип \texttt{T} указателем.
\item \texttt{IsSame} - проверяет, являются ли 2 типа \texttt{T1} и \texttt{T2} одинаковыми.
\item \texttt{RemovePointer} - если тип \texttt{T} является указателем, то возвращает тип того, на что такой указатель указывает (то есть убирает одну "звёздочку" у типа).
\item \texttt{IsHasBegin} - проверяет, есть ли у типа \texttt{T} метод begin.
\end{itemize}
Что такое концепты, как их использовать и зачем они нужны?



\item \textbf{Универсальные ссылки}\\
Правила свёртки ссылок. Универсальные ссылки, чем они отличаются от lvalue и rvalue ссылок? Реализация функции \texttt{std::move}. Идеальная передача. Функция \texttt{std::forward}.

\end{enumerate}

\fi

\end{document}