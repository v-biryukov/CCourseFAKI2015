/*
 * CSE 351 Lab 1 (Data Lab )
 *
 * <Please put your name and userid here>
 *
 * bits.c - Source file with your solutions to the Lab.
 *          This is the file you will hand in to your instructor.
 *
 * WARNING: Do not include the <stdio.h> header; it confuses the dlc
 * compiler. You can still use printf for debugging without including
 * <stdio.h>, although you might get a compiler warning. In general,
 * it's not good practice to ignore compiler warnings, but in this
 * case it's OK.  
 */
 
#if 0
/*
 * Инструкции
 *
 * ШАГ 1: Внимательно прочитайте следующие инструкции.
 */
 
 
 
INTEGER CODING RULES:
 
  Ваши решения должны быть в виде:
 
  int Funct(arg1, arg2, ...) {
      /* краткое описание как работает ваше решение */
      int var1 = Expr1;
      ...
      int varM = ExprM;
 
      varJ = ExprJ;
      ...
      varN = ExprN;
      return ExprR;
  }
 
  Каждое "Expr" это выражение использующее ТОЛЬКО следующее:
  1. Целочисленные константы от 0 до 255 включительно.
      Нельзы использовать большие константы, например такие: 0xffffffff
  2. Аргументы функций и локальные переменные
  3. Унарные операторы ! ~
  4. Бинарные операторы & ^ | + << >>
   
  Некоторые задачи в этом файле ограничивают допустимые деёствия ещё сильнее
  Каждое выражение "Expr" может состоять из нескольких операторов
 
  Остальными конструкциями языка пользоваться запрещено
  В частности запрещены:
  1. Управляющие конструкции if, do, while for и т. д.
  2. Макросы
  3. Писать дополнительные функции
  4. Вызывать функции
  5. Использовать любые операторы, которые не разрешены: &&, ||, - и т. д.
  6. Приведение типов
  7. Использование типов данных отличных от типа int. В частности запрещены
      массивы, структуры и т. д.
 
 
  Можете предполагать, что ваш компьютер:
  1. Использует дополнительный код и 32-х битное представление целых чисел
  2. Использует арифметический правый сдвиг
 
 
ПРИМЕРЫ:
  /*
   * pow2plus1 - возвращает 2^x + 1, где 0 <= x <= 31
   */
  int pow2plus1(int x) {
     /* используем смещение влево для вычисления степени двойки */
     return (1 << x) + 1;
  }
 
  /*
   * pow2plus4 - возвращает 2^x + 4, где 0 <= x <= 31
   */
  int pow2plus4(int x) {
     /* используем смещение влево для вычисления степени двойки */
     int result = (1 << x);
     result += 4;
     return result;
  }
 
ЗАМЕЧАНИЯ:
  1. Используйте компилятор dlc для проверки корректности решений
      Вот так ./dlc bits.c
  2. У каждой функции есть максимальное число операторов которые можно
      использовать ('=' не считается). Это проверяется с помощью dlc  
  3. Использыуйте btest, чтобы проверить ваши решения на правильность
 
/*
 * ШАГ 2: Допишите функции:
 *
 */
 
 
#endif
 
/*
 * bitAnd - x&y используя только ~ и |
 *   Пример: bitAnd(6, 5) = 4
 *   Допустимые операторы: ~ |
 *   Максимальное число операторов: 8
 *   Сложность: 1
 */
int bitAnd(int x, int y) {
  return ~(~x|~y);
}
/*
 * bitXor - x^y используя только ~ and &
 *   Пример: bitXor(4, 5) = 1
 *   Допустимые операторы: ~ &
 *   Max ops: 14
 *   Сложность: 1
 */
int bitXor(int x, int y) {
  return ~(x & y) & ~(~x & ~y);
}
/*
 * thirdBits - возвратите 32-х битое число, чей каждый третий бит 1 (все остальные биты равны 0)
 * (начиная с наименее важного бита)
 *   Пример: ....1001001
 *   Допустимые операторы: ! ~ & ^ | + << >>
 *   Максимальное число операторов: 8
 *   Сложность: 1
 */
int thirdBits(void) {
  int a = 0x49;
  int b = (a << 9);
  int c = b + a;
  return (c << 18) + c;
}
// Сложность: 2
/*
 * fitsBits - возвратите 1 если x может быть представлен как
 *  n-битное целое число в дополнительном коде.
 *   1 <= n <= 32
 *   Примеры: fitsBits(5,3) = 0, fitsBits(-4,3) = 1
 *   Допустимые операторы: ! ~ & ^ | + << >>
 *   Максимальное число операторов: 15
 *   Сложность: 2
 */
int fitsBits(int x, int n) {
  int a = 33 + ~n;
  int b = ((x << a) >> a);
  return !(b + ~x + 1);
}
/*
 *  sign - возвратите 1 если x > 0, 0 если x равно 0, и -1 если x < 0
 *  Примеры: sign(130) = 1
 *           sign(-23) = -1
 *  Допустимые операторы: ! ~ & ^ | + << >>
 *  Максимальное число операторов: 10
 *  Сложность: 2
 */
int sign(int x) {
    return (x >> 31) + (((~x) >> 31) & !!(x << 1));
}
/*
 * getByte - Выделите n-й байт из x
 *   Байты пронумерованы с 0 (LSB) до 3 (MSB)
 *   Примеры: getByte(0x12345678,1) = 0x56
 *   Допустимые операторы: ! ~ & ^ | + << >>
 *   Максимальное число операторов: 6
 *   Сложность: 2
 */
int getByte(int x, int n) {
  return (x >> (n << 3) & (0xFF));
}
// Сложность: 3
/*
 * logicalShift - логический правый сдвиг
 *   Можно предполагать, что 0 <= n <= 31
 *   Примеры: logicalShift(0x87654321,4) = 0x08765432
 *   Допустимые операторы: ~ & ^ | + << >>
 *   Максимальное число операторов: 20
 *   Сложность: 3
 */
int logicalShift(int x, int n) {
  int a = (x >> n);
  int b = ~(~0 << (33 + ~n));
  int c = (a & b);
  return ((((!n) << 31) >> 31) & x) + c;
}
/*
 * addOK - Определите можно ли вычислить x+y без переполнения
 *   Примеры: addOK(0x80000000,0x80000000) = 0,
 *            addOK(0x80000000,0x70000000) = 1,
 *   Допустимые операторы: ! ~ & ^ | + << >>
 *   Максимальное число операторов: 20
 *   Сложность: 3
 */
int addOK(int x, int y) {
  int sum = x + y;
  int sign_x = x >> 31;
  int sign_y = y >> 31;
  int sign_sum = sum >> 31;
  return !(~(sign_x ^ sign_y) & (sign_x ^ sign_sum));
 
}
 
// Сложность: 4
/*
 * bang - Вычислите !x без использования !
 *   Примеры: bang(3) = 0, bang(0) = 1
 *   Допустимые операторы: ~ & ^ | + << >>
 *   Максимальное число операторов: 12
 *   Сложность: 4
 */
int bang(int x) {
  int a = (~x >> 31);
  int b = (a & 1);
  return ((b ^ (((~x + 1) >> 31) & 1)) & b);
}
 
 
 
 
 
// Дополнительное: Сложность: 3
/* invert - Верните x, инвертировав все биты от p до p + n (не включая p+n)
 *          (т.е., измените 0 на 1 и наоборот), остальная часть числа -- неизменна.
 *          Нумерация битов начинается с наименее значимого (наименее значимый = 0)
 *
 *   Можно предполагать, что 0 <= n <= 31 and 0 <= p <= 31
 *   Примеры: invert(0x80000000, 0, 1) = 0x80000001,
 *            invert(0x0000008e, 3, 3) = 0x000000b6,
 *   Допустимые операторы: ! ~ & ^ | + << >>
 *   Максимальное число операторов: 20
 *   Сложность: 3  
 */
int invert(int x, int p, int n) {
  return 2;
}
// Дополнительное: Сложность: 4
/*
 * conditional - тоже, что и x ? y : z
 *   Пример: conditional(2,4,5) = 4
 *   Допустимые операторы: ! ~ & ^ | + << >>
 *   Максимальное число операторов: 16
 *   Сложность: 3
 */
int conditional(int x, int y, int z) {
  int a = ((((x >> 31) | ((~x + 1) >> 31)) << 31) >> 31);
  return ((a & y) + (~a & z));
}
// Дополнительное: Сложность: 5
/*
 * isPower2 - верните 1 если x является степенью 2, и 0 иначе
 *   Примеры: isPower2(5) = 0, isPower2(8) = 1, isPower2(0) = 0
 *   Note that no negative number is a power of 2.
 *   Допустимые операторы: ! ~ & ^ | + << >>
 *   Максимальное число операторов: 20
 *   Сложность: 5
 */
int isPower2(int x) {
  int a = x & (x + (~1 + 1));
  int b = ((!(x >> 31)) & (~(!x)));
  return (!a) & b;
}
