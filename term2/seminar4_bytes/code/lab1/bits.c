/* 
 * CSE 351 Lab 1 (Data Lab )
 * 
 * <Please put your name and userid here>
 * 
 * bits.c - Source file with your solutions to the Lab.
 *          This is the file you will hand in to your instructor.
 *
 * WARNING: Do not include the <stdio.h> header; it confuses the dlc
 * compiler. You can still use printf for debugging without including
 * <stdio.h>, although you might get a compiler warning. In general,
 * it's not good practice to ignore compiler warnings, but in this
 * case it's OK.  
 */

#if 0
/*
 * Инструкции
 *
 * ШАГ 1: Внимательно прочитайте следующие инструкции.
 */



INTEGER CODING RULES:
 
  Ваши решения должны быть в виде: 
 
  int Funct(arg1, arg2, ...) {
      /* краткое описание как работает ваше решение */
      int var1 = Expr1;
      ...
      int varM = ExprM;

      varJ = ExprJ;
      ...
      varN = ExprN;
      return ExprR;
  }
  
  Каждое "Expr" это выражение использующее ТОЛЬКО следующее:
  1. Целочисленные константы от 0 до 255 включительно.
      Нельзы использовать большие константы, например такие: 0xffffffff
  2. Аргументы функций и локальные переменные
  3. Унарные операторы ! ~
  4. Бинарные операторы & ^ | + << >>
    
  Некоторые задачи в этом файле ограничивают допустимые деёствия ещё сильнее
  Каждое выражение "Expr" может состоять из нескольких операторов

  Остальными конструкциями языка пользоваться запрещено
  В частности запрещены:
  1. Управляющие конструкции if, do, while for и т. д.
  2. Макросы
  3. Писать дополнительные функции
  4. Вызывать функции
  5. Использовать любые операторы, которые не разрешены: &&, ||, - и т. д.
  6. Приведение типов
  7. Использование типов данных отличных от типа int. В частности запрещены 
      массивы, структуры и т. д.


  Можете предполагать, что ваш компьютер:
  1. Использует дополнительный код и 32-х битное представление целых чисел
  2. Использует арифметический правый сдвиг


ПРИМЕРЫ:
  /*
   * pow2plus1 - возвращает 2^x + 1, где 0 <= x <= 31
   */
  int pow2plus1(int x) {
     /* используем смещение влево для вычисления степени двойки */
     return (1 << x) + 1;
  }

  /*
   * pow2plus4 - возвращает 2^x + 4, где 0 <= x <= 31
   */
  int pow2plus4(int x) {
     /* используем смещение влево для вычисления степени двойки */
     int result = (1 << x);
     result += 4;
     return result;
  }

ЗАМЕЧАНИЯ:
  1. Используйте компилятор dlc для проверки корректности решений
      Вот так ./dlc bits.c
  2. У каждой функции есть максимальное число операторов которые можно
      использовать ('=' не считается). Это проверяется с помощью dlc  
  3. Использыуйте btest, чтобы проверить ваши решения на правильность

/*
 * ШАГ 2: Допишите функции:
 * 
 */


#endif

/* 
 * getByte - Выделите n-й байт из x
 *   Байты пронумерованы с 0 (LSB) до 3 (MSB)
 *   Примеры: getByte(0x12345678,1) = 0x56
 *   Допустимые операторы: ! ~ & ^ | + << >>
 *   Максимальное число операторов: 6
 *   Сложность: 2
 */
int getByte(int x, int n) {
  return 2;
}



int bitAnd(int x, int y)
{
	return ~((~x) | (~y));
}

int bitXor(int x, int y)
{
	return ((~(x & y)) & (~((~x) & (~y))));
}

int thirdBits(void)
{
	int x = 1;
	x = (x << 3) + 1;
	x = (x << 6) + x;
	x = (x << 12) + x;
	x = (x << 9) + 73;
	return x;
}
int fitsBits(int x, int n)
{
	int r, q;
	q = 33 + ~n;//33-n-1
	r = (x << q) >> q;//Если n-нный бит справа -1 , то первые 32-n битов r - единицы, иначе - нули
	r = r^x; //побитовое ИЛИ.последние n битов зануляются.Если x можно представить в дополнительном коде с n битами, то на этом этапе r=0, иначе не 0
	return !r;

}

/*void show_bytes(pointer start, int len)
{
	int i;
	for (i = 0; i < len; i++)
		printf("%p\t0x%.2x\n", start + i, start[i]);
	printf("\n");
}
int getbyte(int x, int n)
{

}*/

int sign(int x)
{
	return (x >> 31) | (!!x);/*31 старших битов заполняются единицами,если число отрицательное, если положительное, 
							 то 32 старших битов заполняются нулями. последний бит - 1 или 0. Если 1 - x<0, 0 => x>=0*/
	//!!x Если x=0 , !!x=0, иначе !!x=1
}

int bang(int x)
{
	return ((x >> 31) | ((~x + 1) >> 31)) + 1;
}

int addOK(int x, int y) {
	int s = x + y;
	x = x >> 31;
	y = y >> 31;
	return !!(x^y) | (!(x^s) & !(y^s));
}

int logicalShift(int x, int n) {

	int a;
	a = x>> n;
	int q;
	q = (1<< 31)>>(n-1);
	q = ~q;

	return a&q;
}





// Дополнительное: Сложность: 3
/* invert - Верните x, инвертировав все биты от p до p + n (не включая p+n)
 *          (т.е., измените 0 на 1 и наоборот), остальная часть числа -- неизменна. 
 *          Нумерация битов начинается с наименее значимого (наименее значимый = 0)
 *
 *   Можно предполагать, что 0 <= n <= 31 and 0 <= p <= 31
 *   Примеры: invert(0x80000000, 0, 1) = 0x80000001,
 *            invert(0x0000008e, 3, 3) = 0x000000b6,
 *   Допустимые операторы: ! ~ & ^ | + << >>
 *   Максимальное число операторов: 20
 *   Сложность: 3  
 */
int invert(int x, int p, int n) {
  return 2;
}
// Дополнительное: Сложность: 4
/* 
 * conditional - тоже, что и x ? y : z 
 *   Пример: conditional(2,4,5) = 4
 *   Допустимые операторы: ! ~ & ^ | + << >>
 *   Максимальное число операторов: 16
 *   Сложность: 3
 */
int conditional(int x, int y, int z) {
  return 2;
}
// Дополнительное: Сложность: 5
/*
 * isPower2 - верните 1 если x является степенью 2, и 0 иначе
 *   Примеры: isPower2(5) = 0, isPower2(8) = 1, isPower2(0) = 0
 *   Note that no negative number is a power of 2.
 *   Допустимые операторы: ! ~ & ^ | + << >>
 *   Максимальное число операторов: 20
 *   Сложность: 5
 */
int isPower2(int x) {
  return 2;
}
