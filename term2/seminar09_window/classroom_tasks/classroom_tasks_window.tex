\documentclass{article}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{amsmath} 
\usepackage{amsfonts}
\usepackage{upgreek}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{geometry}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{ccaption}
\usepackage{multicol}

\usepackage{listings}
%\setlength{\columnsep}{1.5cm}
%\setlength{\columnseprule}{0.2pt}


\begin{document}
\pagenumbering{gobble}

\lstset{
  language=C,                % choose the language of the code
  basicstyle=\linespread{1.1}\ttfamily,
  columns=fixed,
  fontadjust=true,
  basewidth=0.5em,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray},
  stringstyle=\ttfamily\color{orange!50!black},
  showstringspaces=false,
  %numbers=false,                   % where to put the line-numbers
  numbersep=5pt,
  numberstyle=\tiny\color{black},
  numberfirstline=true,
  stepnumber=1,                   % the step between two line-numbers.        
  numbersep=10pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
  showstringspaces=false,         % underline spaces within strings
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=true,         % sets if automatic breaks should only happen at whitespace
  xleftmargin=.2in,
  extendedchars=\true,
  keepspaces = true,
}
\lstset{literate=%
   *{0}{{{\color{red!20!violet}0}}}1
    {1}{{{\color{red!20!violet}1}}}1
    {2}{{{\color{red!20!violet}2}}}1
    {3}{{{\color{red!20!violet}3}}}1
    {4}{{{\color{red!20!violet}4}}}1
    {5}{{{\color{red!20!violet}5}}}1
    {6}{{{\color{red!20!violet}6}}}1
    {7}{{{\color{red!20!violet}7}}}1
    {8}{{{\color{red!20!violet}8}}}1
    {9}{{{\color{red!20!violet}9}}}1
}


\title{Семинар \#9: Подключение библиотек. Создание окна с помощью библиотеки SFML \vspace{-5ex}}\date{}\maketitle

\section*{Часть 1: Многофайловые программы. Библиотеки}
\subsection*{Этапы сборки проекта на языке \texttt{C++}:}
\begin{enumerate}
\item \textbf{Препроцессинг}. Обрабатываются директивы компилятора \texttt{\#include}, \texttt{\#define} и другие. Удаляются комментарии. Чтобы исполнить только этот шаг, нужно передать компилятору опцию \texttt{-E}:
\begin{verbatim}
g++ -E main.cpp > preprocessed.cpp
\end{verbatim}
\item \textbf{Компиляция}: каждый файл исходного кода (файл расширения \texttt{.cpp}) транслируется в код на языке ассемблера. Чтобы исполнить только этапы препроцессинга и компиляции, нужно передать компилятору опцию \texttt{-S}:
\begin{verbatim}
g++ -S main.cpp
\end{verbatim}
\item \textbf{Ассемблирование}: каждый файл на языке ассемблера транслируется в машинный код. В результате создаётся объектный файл с расширением \texttt{.o}. Чтобы исполнить процесс до этой стадии включительно нужно передать компилятору опцию \texttt{-c}:
\begin{verbatim}
g++ -c main.cpp
\end{verbatim}
\item \textbf{Линковка}: Все объектные файлы сливаются друг с другом, а также с другими библиотеками. Даже если ваш проект состоит из одного файла, вы наверняка используйте как минимум стандартную библиотеку и на этом этапе ваш код соединяется с другими библиотеками.
\begin{verbatim}
g++ main.o
\end{verbatim}
\end{enumerate}


\subsection*{Задание:}
\begin{itemize}
\item В папке \texttt{0stages} лежит исходный код простой программы. Пройдите поэтапно все стадии сборки с этой программой.
\end{itemize}

\subsection*{Сборка многофайловой программы:}
\begin{center}
\includegraphics[scale=0.7]{../images/separate_compilation_linking.png}
\end{center}
Можно собрать всё сразу:
\begin{lstlisting}
g++ main.cpp particle.cpp v3.cpp
\end{lstlisting}
Либо можно собрать по частям:
\begin{lstlisting}
g++ -c main.cpp
g++ -c particle.cpp
g++ -c v3.cpp
g++ main.o particle.o v3.o
\end{lstlisting}

\subsection*{Виды библиотек:}
\begin{enumerate}
\item \textbf{header-only библиотеки:} Весь исходный код хранится в \texttt{.h} файле и подключается с помощью директивы \texttt{\#include} (очень просто подключить).
\item \textbf{Исходный код:} Библиотека поставляется в виде исходного кода (все \texttt{.h} и \texttt{.cpp} файлы). Для того чтобы использовать эту библиотеку, её нужно сначала скомпилировать, что может быть очень непросто для больших библиотек, так как процесс сборки может сильно отличаться на разных операционных системах и компиляторах.
\item \textbf{Статическая библиотека:} Библиотека поставляется в виде header-файлов(\texttt{.h}) и предварительно скомпилированных файлов библиотеки Расширение статических библиотек на linux: \texttt{.a} (archive). Расширение на windows: \texttt{.lib} (library). Эти библиотеки подключаются на этапе линковки. После линковки содержимое этих библиотек содержится в исполняемом файле. Такие библиотеки проще подключить к проекту, чем исходный код. Однако, вам обязательно иметь версию библиотеки, скомпилированную на такой же ОС и на таком же компиляторе, иначе она не подключится. Обратите внимание, что статические библиотеки обязательно должны иметь префикс \texttt{lib}. Например, если мы хотим получить библиотеку под названием \texttt{image}, то файл должен называться \texttt{libimage.a}.
\item \textbf{Динамическая библиотека:} Библиотека поставляется в виде header-файлов(\texttt{.h}) и предварительно скомпилированных файлов библиотеки Расширение динамических библиотек на linux: \texttt{.so} (от shared object). Расширение на windows: \texttt{.dll} (от dynamic link library)). Эти библиотеки подключаются на этапе \textit{выполнения программы}. Благодаря тому, что динамическая библиотека подключается на этапе выполнения, если несколько программ будут использовать одну и ту же библиотеку, то она будет загружаться в память лишь один раз.
\end{enumerate}

\subsection*{Задания:}
\begin{itemize}
\item \textbf{header:} В папке \texttt{1image/0header-only} лежит исходный код программы, которая использует класс \texttt{Image}. Это простой класс для работы с изображениями в формате \texttt{.ppm}. Скомпилируйте и запустите эту программу.
\item \textbf{Случайные отрезки:} Используйте этот класс, чтобы создать изображение, состоящее из 100 случайных отрезков случайного цвета. Для случайных чисел используйте функцию \texttt{rand()} из библиотеки \texttt{<cstdlib>}.
\item \textbf{Случайные прямоугольники:} Добавьте в этот класс метод \\
\texttt{void draw\_rectangle(const Vector2i\& bottomleft, const Vector2i\& torright, const Color\& color)}. Используйте этот метод, чтобы создать изображение, состоящее из 100 случайных прямоуголиников случайного цвета.
\item \textbf{Шум:} Добавьте в этот класс метод \texttt{void add\_noise(float probability)}, который будет добавлять шум на картинку: каждый пиксель с вероятностью \texttt{probability} должен поменять цвет на случайный. Протестируйте этот метод на картинках.
\item \textbf{Раздельная компиляция:} В папке \texttt{1image/1separate\_compilation} лежит тот же код, но разделённый на 2 файла исходного кода. Скомпилируйте эту программу с помощью \texttt{g++}.Добавьте функции \texttt{draw\_rectangle} и \texttt{add\_noise} из предыдущих заданий в этот проект.
\item \textbf{Статическая библиотека:} Чтобы создать свою статическую библиотеку вам нужно:
\begin{enumerate}
\item Создать объектный файл необходимого исходного файла.
\item Превратить объектный файл (или файлы) в библиотеку, используя утилиту \texttt{ar}:
\begin{verbatim}
ar rvs libimage.a image.o
\end{verbatim}
\item После этого файл \texttt{libimage.a} можно будет подключить к любому другому проекту примерно так:
\begin{verbatim}
g++ main.cpp -I<путь до header-файлов> -L<путь до libimage.a> -limage
\end{verbatim}
\end{enumerate}
В папке \texttt{1image/2static\_library} лежит исходный код программы. Вам нужно создать статическую библиотеку из файла \texttt{image.cpp} и поместить полученный файл в папку \texttt{image/lib}, а header-файл поместить в папку \texttt{image/include}. Затем вам нужно удалить файл \texttt{image.cpp} и собрать программу используя только статическую библиотеку (не забывайте про опции \texttt{-I}, \texttt{-L} и \texttt{-l}).
\item \textbf{Статическая библиотека 2:} В папке \texttt{1image/3static\_test} лежит проект с одной очень маленькой статической библиотекой (содержит 1 функцию). Вам нужно собрать этот проект и запустить исполняемый файл.
\item \textbf{Динамическая библиотека:} Чтобы создать динамическую библиотеку из файла исходного кода (\texttt{image.cpp}):
\begin{verbatim}
g++ -c -fPic image.cpp -o image.o
g++ -shared -o libimage.so image.o
\end{verbatim}
Чтобы скомпилировать код с подключением динамической библиотеки:
\begin{verbatim}
g++ -o main.exe main.cpp libimage.so
\end{verbatim}
или
\begin{verbatim}
g++ -o main.exe main.cpp -limage
\end{verbatim}
Но для этого понадобится добавить в переменную среды \texttt{LD\_LIBRARY\_PATH} (на Windows нужно добавить в переменную среды \texttt{PATH}) путь до папки, содержащий библиотеку.
\begin{enumerate}
\item Создайте динамическую библиотеку и скомпилируйте саму программу с подключением динамической библиотеки
\item Проверьте чему равен размеры исполняемых файлов в случае подключения статической и динамической библиотеки.
\item Что будет происходить, если перенести файл динамической библиотеки в другую папку. Запустится ли исполняемый файл?
\end{enumerate}
\end{itemize}

\newpage
\section*{Часть 2: Библиотека SFML:}
Библиотека SFML (Simple and Fast Multimedia Library) - простая и быстрая библиотека для работы с мультимедиа. Кроссплатформенная (т. е. одна программа будет работать на операционных системах Linux, Windows и MacOS). Позволяет создавать окно, рисовать в 2D и 3D, проигрывать музыку и передавать информацию по сети. Для подключения библиотеки вам нужно скачать нужную версию с сайта: \href{https://www.sfml-dev.org/}{sfml-dev.org}.

\subsubsection*{Подключение вручную:}
Для подключения библиотеки вручную через опции \texttt{g++} нужно задать путь до папок \texttt{include/} и \texttt{lib/} и названия файлов библиотеки, используя опции \texttt{-I}, \texttt{-L} или \texttt{-l}. 
\begin{verbatim}
g++ .\main.cpp -I<путь до include> -L<путь до lib> -lsfml-graphics -lsfml-window -lsfml-system
\end{verbatim}
Например так:
\begin{verbatim}
g++ .\main.cpp -I./SFLL-2.5.1/include -L./SFLL-2.5.1/lib -lsfml-graphics -lsfml-window -lsfml-system
\end{verbatim}

\subsubsection*{\texttt{bash}-скрипт:} Так как постоянно прописывать в терминале сборку проекта может быть затруднительно, то можно положить весь процесс сборки в специальный \texttt{bash}-скрипт. \texttt{bash}-скрипт - это просто файл кода языка терминала linux. (Для windows есть аналогичные \texttt{bat}-скрипты) Пример можно посмотреть в \texttt{2sfml/1bash\_script}.

\subsubsection*{Makefile:} \texttt{make} -- это специальная утилита, предназначенная для упрощения сборки проекта. В \texttt{2sfml/3makefile} содержится пример проекта с make-файлом. Содержимое make-файла представляет собой просто набор целей и соответствующих команд оболочки \texttt{bash}. Откройте make-файл и просмотрите его содержимое. Чтобы скомпилировать его просто:
\begin{verbatim}
make <имя цели>
\end{verbatim}
либо просто
\begin{verbatim}
make
\end{verbatim}
(в этом случае \texttt{make} запустит процесс создания первой цели)

\subsection*{Задания:}
\begin{itemize}
\item \textbf{Сборка:} скомпилируйте и запустите проект. Используйте \texttt{bash}-скрипт или make-файл. Более подробно -- в папке \texttt{2sfml}.
\item \textbf{Движение по окружности:} Заставьте кружок двигаться по окружности. 
\item \textbf{Броуновское движение:} Создайте \texttt{n = 50} кругов, которые будут двигаться случайным образом (направление и величина движения должны задаваться случайным образом на каждом кадре).
\item \textbf{Задача n тел:} Создайте \texttt{n = 50} кругов, так, чтобы они притягивались друг к другу гравитационной силой. Начальные положения и скорости задайте случайным образом. Сила гравитации в двух измерениях обратно пропорциональна расстоянию между объектами.
$$
F \sim \frac{1}{R}
$$
\item \textbf{Задача N тел с массой} \\
Добавьте разную массу шарикам. При создании шарика масса должна задаваться случайным образом. Масса шарика должна быть пропорциональна площади (квадрату радиуса).
\item \textbf{Электрические заряды} \\
Смоделируйте взаимодействие заряженных частиц. Для этого нужно добавить поле в структуру \texttt{Ball}, которое будет определять величину заряда. Эта величина может быть как положительной, так и отрицательной. В начале работы программы заряд должен задаваться случайно. Заряды должны взаимодействовать по закону Кулона. Гравитацией можно пренебречь. Цвета зарядов должны быть различными (красный для положительного зарада и синий для отрицательного, интенсивность цвета - пропорциональна величине заряда).
\item \textbf{Нажатие мыши} \\
События нажатия мыши можно обработать с помощью следующего синтаксиса:
\begin{lstlisting}
if (event.type == sf::Event::MouseButtonPressed) 
{
    if (event.mouseButton.button == sf::Mouse::Right) 
    {
        std::cout << "the right button was pressed" << std::endl;
        std::cout << "mouse x: " << event.mouseButton.x << std::endl;
        std::cout << "mouse y: " << event.mouseButton.y << std::endl;
    }
}
\end{lstlisting}
Внутри цикла \texttt{while (window.pollEvent(event))}.\\
Видоизмените вашу программу так, чтобы при нажатии левой кнопки мыши в том месте, где находится мышь, создавался бы шарик со средними массой и средним положительным зарядом зарядом. При нажатии правой кнопки мыши должен создаваться шарик с очень большой  массой и очень большим положительным зарядом. При аналогичных нажатиях, но с зажатой клавишой Shift, должны создаваться отрицательные заряды.
\end{itemize}

\newpage



\section*{Часть 1: Основные типы и классы библиотеки SFML}
\subsubsection*{Типы целых чисел}
Так как библиотека SFML кросплатформенная, то в ней введены \texttt{typedef}-синонимы для целочисленных типов, например \texttt{Int8}, \texttt{Int64}, \texttt{Uint32} и другие. Эти типы гарантируют, что они будут соответствующего размера.

\subsubsection*{Классы математических векторов}
Классы двумерных математических векторов \texttt{sf::Vector2<T>}. У них есть два публичных поля: \texttt{x} и \texttt{y}. Также, для них перегруженны операции сложения с такими же векторами и умножения на числа. Также введены \texttt{typedef}-синонимы вроде \texttt{sf::Vector2f} для \texttt{sf::Vector2<float>} и другие.

\subsubsection*{Класс цвета}
Класс цвета \texttt{sf::Color}. Имеет 4 публичных поля: \texttt{r}, \texttt{g}, \texttt{b}, \texttt{a} - компоненты цвета в цветовой модели RGB и прозрачность. Есть конструктор от 3-х или 4-х аргументов. Есть перегруженные операции для сравнения и сложения цветов. Есть уже определённые цвета вроде \texttt{sf::Color::Blue} и другие.

\subsubsection*{Класс строки}
В SFML есть свой класс строки под названием \texttt{sf::String}. Поддерживает разные виды кодировок. Имеет конструкторы от стандартных строк \texttt{C++} и строк в стиле \texttt{C}.

\subsubsection*{Класс окна}
Прежде чем начать рисовать, нужно создать окно, которое будет отображать то, что мы нарисовали. Для этого в SFML есть класс \texttt{sf::RenderWindow}. Вот его основные методы:
\begin{itemize}
\item \texttt{RenderWindow(sf::VideoMode m, const sf::String\& title, sf::Uint32 style, sf::ContextSettings\& s)}
Конструктрор, с двумя обязательными и двумя необязательными аргументами. Его аргументы:
\begin{itemize}
\item Видеорежим - определяет размер окна.
\item Заголовок окна
\item Стиль окна, необязательный аргумент, может принимать следующие значения:
\begin{itemize}
\item[-] \texttt{sf::Style::None}
\item[-] \texttt{sf::Style::Titlebar} -- окно с заголовком
\item[-] \texttt{sf::Style::Resize}  -- окно у которого можно менять размер
\item[-] \texttt{sf::Style::Close} -- окно с кнопочкой закрывания
\item[-] \texttt{sf::Style::Fullscreen} -- полноэкранный режим
\item[-] \texttt{sf::Style::Default = sf::Titlebar | sf::Resize | sf::Close} 
\end{itemize}
Этот параметр имеет значение по умолчанию (\texttt{sf::Default}).

\item Дополнительные настройки контекста OpenGL, необязательный аргумент.
\end{itemize}

\item \texttt{getPosition} и \texttt{setPosition} - получить или установить положение окна.
\item \texttt{getSize} и \texttt{setSize} - получить или установить размер окна в пикселях.
\item \texttt{setFramerateLimit} -- установить лимит для количества кадров в секунду.
\item \texttt{clear} - принимает цвет и очищает скрытый холст этим цветом
\item \texttt{draw} - рисует объект на скрытый холст
\item \texttt{display} - отображает на экран всё что было нарисовано на скрытом холсте
\end{itemize}


\subsubsection*{Классы фигур}
В SFML есть несколько классов для работы с простыми фигурами: \texttt{sf::CircleShape} (круг или элипс),\\ \texttt{sf::RectangleShape} (прямоугольник), \texttt{sf::ConvexShape} (фигура сложной формы, задаваемая точками). У этих классов есть общие методы:
\begin{itemize}
\item \texttt{setOrigin} - установить локальное начало координат фигуры. Положение этой точки задаётся относительно верхнего левого угла прямоугольника, ограничивающего фигуру. По умолчанию эта точка равна \texttt{(0, 0)}, то есть локальным началом координат фигуры считается её верхний левый угол.  Эта точка важна, так как относительно неё происходят все операции поворота и масштабирования.
\item \texttt{setPosition}, \texttt{getPosition} - задать и получить координаты фигуры. Фигура перемещается таким образом, чтобы её \texttt{origin} оказался в заданой точке.
\item \texttt{move} - принимает 2D вектор и передвигает фигуру на этот вектор.
\item \texttt{setRotation}, \texttt{getRotation} - задать и получить угол (в градусах) вращения фигуры вокруг точки \texttt{origin}
\item \texttt{rotate} - принимает вещественное число и вращает фигуру на этот угол (в градусах)
\item \texttt{setScale}, \texttt{getScale} - задать и получить величину масштабирования (2D вектор)
\item \texttt{scale} - принимает  2D вектор и растягивает или сжимает фигуру по x и по y соответственно
\item \texttt{setFillColor}, \texttt{getFillColor} -- устанавливает/возвращает цвет заливки фигуры
\end{itemize}

\subsubsection*{Задачи:}
\begin{itemize}
\item В папке \texttt{00circle} приведён пример программы, которая рисует круг. Измените эту программу, чтобы круг рисовался в левом верхнем углу экрана.
\item Измените эту программу, чтобы круг рисовался в правом нижнем углу экрана.
\item Нарисуйте 100 кругов в случайных местах экрана, случайного размера и случайного цвета.
\item В папке \texttt{01shapes} приведён пример программы, которая рисует несколько фигур. Используйте методы выше и сделайте так, чтобы круг двигался по прямой, прямоугольник вращался, а фигура сложной формы сжималась по y и растягивалась по x. Подберите скорости этих операций, чтобы они были не слишком быстрыми.
\item Перейдите в полноэкранный режим
\end{itemize}

\subsubsection*{Anti-Aliasing}
\begin{multicols}{2}
\begin{center}
\includegraphics[scale=0.5]{../images/anti-aliasing.png}
\end{center}
Вы могли заметить, что фигуры выглядят не очень красиво - имеют зазубрены. Это связано с тем, что рисования происходит на прямоугольной сетке пикселей и при проведении линий под углом образуются ступеньки. Для борьбы с этим эффектом был придуман специальный метод сглаживания, который называется антиалиасинг. Он уже автоматически реализован во всех библиотеках компьютерной графики. Чтобы установить его в SFML, нужно прописать опцию:
\begin{lstlisting}
sf::ContextSettings settings;
settings.antialiasingLevel = 8;
\end{lstlisting}
И передать \texttt{settings} на вход для конструктора \texttt{RenderWindow}. Пример в папке \texttt{02antialiasing}.
\end{multicols}

\newpage
\subsection*{Главный цикл}
Как правило, у любой программы, работающей на основе событийно-ориентированной модели, есть главный цикл. На каждой итерации данного цикла программа должна проделать все необходимые операции по подготовке и отрисовке следующего кадра. Число итераций этого цикла называется числом кадров в секунду (англ. frames per seconds - fps).

В папке \texttt{4mainloop} предсталена простейшая программа с главным циклом. Сейчас основной цикл программы работает без перерывов и, так как наша программа очень проста, то количество кадров в секунду может достигать огромных значений - больше 1000 fps. Мониторы не обновляют экран с такой скоростью и человеческий глаз тоже не способен воспринять такую частоту кадров. Поэтому не имеет смысла задавать fps очень высоким, его желательно ограничить. Это можно сделать с помощью метода \texttt{setFramerateLimit}. Пример в папке \texttt{06framerate\_limit}.

Этот метод ограничивает лишь максимальное количество кадров. Если за один кадр выполняется много вычислений, то fps может просесть ниже 60. Из за этого программы, которые завязанны на времени, могут работать некорректно. Например, в нашем примере скорость движения шарика зависит от числа кадров в секунду. Чтобы шарик двигался одинаково независимо от fps нужно высчитывать время, занятое на каждом кадре. Пример, как это делать в папке \texttt{07clock\_time}.

\subsubsection*{Класс времени}
Класс \texttt{sf::Time} для работы со временем. Есть методы \texttt{asSeconds}, \texttt{asMilliseconds} и \texttt{asMicroseconds}, которые возвращают время в виде числа в соответствующих единицах. Перегружены операторы сложения, умножения и другие. Есть дружественные функции \texttt{sf::seconds}, \texttt{sf::milliseconds} и \texttt{sf::microseconds}, которые принимают число, и возвращают соответствующие объект класса \texttt{sf::Time}.

\subsubsection*{Класс часов}
\texttt{sf::Clock} -- это маленький класс для измерения времени. У него есть:
\begin{itemize}
\item Конструктор по умолчанию, часы запускаются автоматически после создания.
\item Метод \texttt{getElapsedTime()} -- возвращает объект \texttt{sf::Time} -- время прошедшее с последнего запуска часов.
\item Метод \texttt{restart()} -- заново запускает часы.
\end{itemize}

\subsection*{Проверка на нажатие клавиш и кнопок}
\subsubsection*{Класс клавиатуры}
Класс клавиатуры \texttt{sf::Keyboard}. Внутри этого класса, в публичной части, объявлен перечисляемый тип \texttt{Key}, в котором перечислены все клавиши. Например, чтобы проверить нажатие на пробел понадобится \texttt{sf::Keyboard::Space}. Название всех клавиш можно найти по следующей ссылке: \href{https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Keyboard.php}{Тут}.\\
У этого класса есть метод 
\begin{itemize}
\item \texttt{isKeyPressed} -- принимает клавишу и проверяет нажата ли она.
\end{itemize}
Пример -- в папке \texttt{08is\_key\_pressed}.


\subsubsection*{Класс мыши}
Класс мыши \texttt{sf::Mouse}. Внутри этого класса, в публичной части, объявлен перечисляемый тип \texttt{Button} в котором перечислены все кнопки мыши.
У этого класса есть метод:
\begin{itemize}
\item \texttt{isButtonPressed} принимает на вход \texttt{sf::Mouse::Button} и проверяет нажата ли соответствующая кнопка.
\item \texttt{getPosition()} -- возвращает положение мыши на в координатах всего экрана.
\item \texttt{setPosition(const sf::Vector2i\&)} --  устанавливает положение мыши на в координатах всего экрана
\item \texttt{getPosition(const sf::Window\&)} -- возвращает положение мыши на в координатах данного окна.
\item \texttt{setPosition(const sf::Vector2i\&, const sf::Window\&)} --  устанавливает положение мыши на в координатах данного окна.
\end{itemize}
Пример -- в папке \texttt{09is\_button\_pressed}.

\subsubsection*{Задачи:}
\begin{itemize}
\item Создайте 2 объекта: круг и квадрат. Круг должен двигаться при нажатии на стрелки. Квадрат должен двигаться при нажатии на \texttt{WASD}.
\item Сделайте так, чтобы при нажатии на левую кнопку мыши координаты круга становились бы равными координатам мыши.
\item Сделайте так, чтобы при нажатии на \texttt{Enter} цвет квадрата менялся случайным образом каждый кадр.
\item Сделайте так, чтобы квадрат передвигался вправо на 50 пикселей каждые 2 секунды. При этом, все остальное должно работать как прежде, то есть функцию \texttt{sf::sleep} использовать не получится.
\item Сделайте так, чтобы цвет круга плавно зависел от положения курсора на экране.

\item Создайте новый круг белого цвета и сделайте так, чтобы при наведении на него курсора, он становился красным.
\end{itemize}


\subsection*{Работа с текстом}
Для работы с текстом есть два класса. Класс шрифта \texttt{sf::Font} и класс текста \texttt{sf::Text}. Пример работы с текстом в папке \texttt{03text}.
\subsubsection*{Задачи:}
\begin{itemize}
\item Создайте вращающийся текст.
\item Сделайте так, чтобы при нажатии клавиши пробел у текста задавалась случайная позиция, случайный поворот, случайный цвет и случайное масштабирование(в разумных пределах).
\item Создайте 2 поля текста. В первом нужно печатать положение мыши в системе отсчёта всего экрана. Во втором поле текста нужно печатать координаты мыши в системе отсчёта окна. Для перевода чисел в строку используйте функцию \texttt{std::to\_string}.
\end{itemize}


\newpage

\section*{Часть 2: События}
\begin{itemize}

\item \textbf{KeyPressed:} В папке \texttt{1key\_events} лежит пример программы, которая обрабатывает нажатия клавиш. Измените программу так, чтобы при нажатии на клавишу Enter кружок менял цвет на случайный.

\item \textbf{KeyReleased:} Измените программу так, чтобы при \textit{отпускании} клавиши пробел прямоугольник менял цвет на случайный (событие \texttt{sf::Event::KeyReleased}).

\item \textbf{MouseButtonPressed:} В папке \texttt{2mouse\_events} лежит пример программы, которая обрабатывает нажатия и движение мыши. Измените программу так, чтобы при нажатии на правую кнопку мыши, прямоугольник перемещался к положению мыши. Событие должно срабатывать только в момент нажатия, прямоугольник не должен двигаться при зажатии кнопки.
\begin{lstlisting}
if (event.type == sf::Event::MouseButtonPressed)
{
    if (event.mouseButton.button == sf::Mouse::Right)
    {
        std::cout << "the right button was pressed" << std::endl;
        std::cout << "mouse x: " << event.mouseButton.x << std::endl;
        std::cout << "mouse y: " << event.mouseButton.y << std::endl;
    }
}
\end{lstlisting}


\item \textbf{MouseMoved:} Событие, которое срабатывает тогда, когда двигается мышь.
\begin{lstlisting}
if (event.type == sf::Event::MouseMoved)
{
    std::cout << "new mouse x: " << event.mouseMove.x << std::endl;
    std::cout << "new mouse y: " << event.mouseMove.y << std::endl;
}
\end{lstlisting}
Измените программу так, чтобы прямоуголиник окрашивался в красный цвет тогда и только тогда, когда курсор мыши находится на прямоугольнике. Во всё остальное время прямоуголиник должен быть зелёным.

\item \textbf{Перетаскивание:} Создайте новый прямоугольник и сделайте его перетаскиваемым. При нажатии на него и последующим движении мыши он должен начать двигаться вместе с курсором. При отпускании мыши должен остаться на месте.



\end{itemize}

\newpage
\section*{Часть 3: Задачи}
\begin{itemize}
\item \textbf{Кнопка:} Создайте "кнопку". Кнопка представляет собой прямоугольник и некий текст поверх этой кнопки. Логика работы должна быть аналогичной логике работы обычной кнопки в ОС Windows. При наведении на прямоугольник он должен немного менять цвет. При зажатии кнопки мыши на прямоугольнике он должен менять цвет на третий. Кнопка должна быть зажата пока зажата кнопка мыши, даже если курсор уже вышел за пределы кнопки. При отпускании мыши, если курсор всё ещё находится на прямоугольнике, должно срабатывать некоторое действие. В качестве действия -- пусть круг будет менять цвет на случайный.

\begin{itemize}
\item Создайте свой класс \texttt{Button}, который будет описывать данное поведение.
\item Используйте этот класс и создайте 4 кнопки с надписями \texttt{Left}, \texttt{Right}, \texttt{Down}, \texttt{Up}. При нажатии на эти кнопки круг должен перемещаться на 20 пикселей в соответствующем направлении. 
\end{itemize}

\item \textbf{Шарики:} В папке \texttt{collision\_circles} содержится заготовка кода. 
\begin{itemize}
\item Используйте этот код, чтобы найти пересечение двух шаров. Если в процессе движения шары начнут накладываются друг на друга, то они должны окрашиваться в красный цвет. После прекращения наложения, шары должны опять стать белыми. Для этого добавьте поле типа \texttt{sf::Color} в класс \texttt{Ball} и метод \texttt{bool is\_colliding(const Ball\& b) const}, который будет проверять 2 кружка на столкновение.
\item Измените программу так, чтобы кружки упруго отскакивали друг от друга. Для этого нужно, при столкновении шариков, обратить составляющую скорости параллельную прямой, соединяющую центры шариков.
\item Добавьте возможность добавления нового шарика по нажатию правой кнопки мыши.
\item Добавьте возможность стенки по нажатию левой кнопки мыши. Нужно зажать ЛКМ в одной точки и отпустить в другой, чтобы получить стенку. Стенка -- это просто отрезок. Но шарики должны от него должны отскакивать. Про обнаружение столкновений можно посмотреть в папке \texttt{collision\_examples}.
\end{itemize}



\item \textbf{Pong:} Создайте игру Pong на 2 игрока. Первый игрок должен управлять ракеткой используя клавиши \texttt{W} и \texttt{S}. Второй игрок -- стрелочки вниз и вверх.
\begin{center}
\includegraphics[scale=0.5]{../images/pong.png}
\end{center}
\end{itemize}



\end{document}